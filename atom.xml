<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>coldwarm7</title>
  
  <subtitle>天行健，君子以自强不息</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-22T13:58:01.982Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>辞树</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jsp无法引入js文件解决办法</title>
    <link href="http://yoursite.com/2018/10/22/jsp%E6%97%A0%E6%B3%95%E5%BC%95%E5%85%A5js%E6%96%87%E4%BB%B6%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://yoursite.com/2018/10/22/jsp无法引入js文件解决办法/</id>
    <published>2018-10-22T13:49:10.000Z</published>
    <updated>2018-10-22T13:58:01.982Z</updated>
    
    <content type="html"><![CDATA[<center>jsp文件导入路径正确但是无法引入js文件</center><a id="more"></a><h1 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h1><p><img src="http://coldwarm7.oss-cn-beijing.aliyuncs.com/18-10-22/31995981.jpg" alt=""></p><h1 id="js导入路径"><a href="#js导入路径" class="headerlink" title="js导入路径"></a>js导入路径</h1><p><img src="http://coldwarm7.oss-cn-beijing.aliyuncs.com/18-10-22/58572584.jpg" alt=""></p><blockquote><p>导入路径正确并且在idea中ctrl可以找到js文件</p></blockquote><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>访问被拦截住了.最后分析查找得知,是因为在web.xml缺少了SpringMVC拦截设置.</p><p>注意: 下面这段代码,要写在引入springMVC代码前。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置拦截路径 --&gt; </span><br><span class="line">&lt;!-- 同样道理,也对其他的后缀名进行了设置 --&gt; </span><br><span class="line">&lt;servlet-mapping&gt; </span><br><span class="line">    &lt;servlet-name &gt;default &lt;/servlet-name &gt;  </span><br><span class="line">    &lt;url-pattern &gt;*.js&lt;/url-pattern&gt;  </span><br><span class="line">&lt;/servlet-mapping &gt; </span><br><span class="line">&lt;servlet-mapping &gt; </span><br><span class="line">    &lt;servlet-name &gt;default &lt;/servlet-name &gt;  </span><br><span class="line">    &lt;url-pattern &gt;*.css&lt;/url-pattern&gt;  </span><br><span class="line">&lt;/servlet-mapping &gt; </span><br><span class="line">&lt;servlet-mapping &gt; </span><br><span class="line">    &lt;servlet-name &gt;default &lt;/servlet-name &gt;  </span><br><span class="line">    &lt;url-pattern &gt;*.htm&lt;/url-pattern&gt;  </span><br><span class="line">&lt;/servlet-mapping &gt; </span><br><span class="line">&lt;servlet-mapping &gt; </span><br><span class="line">    &lt;servlet-name &gt;default &lt;/servlet-name &gt;  </span><br><span class="line">    &lt;url-pattern &gt;*.gif&lt;/url-pattern&gt;  </span><br><span class="line">&lt;/servlet-mapping &gt;</span><br></pre></td></tr></table></figure><blockquote><p>servlet-mapping是用于servlet的路径映射配置，其中url-pattern为指定的映射拦截路径。 在SpringMVC中，url-pattern指定了spring需要拦截派发的路径。</p></blockquote><hr><p>参考链接：<a href="https://www.jianshu.com/p/abc5822dd882" target="_blank" rel="noopener">https://www.jianshu.com/p/abc5822dd882</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;jsp文件导入路径正确但是无法引入js文件&lt;/center&gt;
    
    </summary>
    
      <category term="遇到的问题" scheme="http://yoursite.com/categories/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="springmvc" scheme="http://yoursite.com/tags/springmvc/"/>
    
  </entry>
  
  <entry>
    <title>redis的持久化</title>
    <link href="http://yoursite.com/2018/10/10/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://yoursite.com/2018/10/10/redis的持久化/</id>
    <published>2018-10-10T08:37:58.000Z</published>
    <updated>2018-10-10T08:50:34.839Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://coldwarm7.oss-cn-beijing.aliyuncs.com/18-10-10/38280048.jpg" alt=""></center><a id="more"></a><h1 id="RDB-Redis-DataBase"><a href="#RDB-Redis-DataBase" class="headerlink" title="RDB(Redis DataBase)"></a>RDB(Redis DataBase)</h1><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p><blockquote><p>RDB最后一次持久化数据丢失的情况：例如每隔两分钟进行一次数据的持久化，在1：59s的时候因为外部原因（关机/停电。。）那么这1：59s内对数据的修改就会丢失，没有来得及进行持久化</p></blockquote><blockquote><p>fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）<br>数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</p></blockquote><p><strong>rdb 保存的是dump.rdb文件</strong></p><h2 id="快照持久化是Redis默认采用的持久化方式，在redis-conf配置文件中默认有此下配置："><a href="#快照持久化是Redis默认采用的持久化方式，在redis-conf配置文件中默认有此下配置：" class="headerlink" title="快照持久化是Redis默认采用的持久化方式，在redis.conf配置文件中默认有此下配置："></a>快照持久化是Redis默认采用的持久化方式，在redis.conf配置文件中默认有此下配置：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save 900 1              #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10            #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br></pre></td></tr></table></figure><h2 id="如何触发RDB快照"><a href="#如何触发RDB快照" class="headerlink" title="如何触发RDB快照"></a>如何触发RDB快照</h2><ul><li><strong>BGSAVE</strong>：客户端向Redis发送 BGSAVE命令 来创建一个快照。对于支持BGSAVE命令的平台来说（基本上所有平台支持，除了Windows平台），Redis会调用fork来创建一个子进程，然后子进程负责将快照写入硬盘，而父进程则继续处理命令请求。</li><li><strong>save</strong>：save时只管保存，其它不管，全部阻塞(save时不能进行数据注入)</li><li><strong>save选项</strong>： 如果用户设置了save选项（一般会默认设置），比如 save 60 10000，那么从Redis最近一次创建快照之后开始算起，当“60秒之内有10000次写入”这个条件被满足时，Redis就会自动触发BGSAVE命令。(save [秒数] [次数])</li><li><strong>SHUTDOWN命令</strong>： 当Redis通过SHUTDOWN命令接收到关闭服务器的请求时，或者接收到标准TERM信号时，会执行一个SAVE命令，阻塞所有客户端，不再执行客户端发送的任何命令，并在SAVE命令执行完毕之后关闭服务器。</li><li><strong>恢复：</strong> 冷拷贝后重新使用（将备份文件 <code>dump.rdb</code> 移动到 redis 安装目录并启动服务即可）</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>适合大规模的数据恢复</li><li>对数据完整性和一致性要求不高</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就<br>会丢失最后一次快照后的所有修改</li><li>fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li></ul><p><img src="http://coldwarm7.oss-cn-beijing.aliyuncs.com/18-10-10/13435098.jpg" alt=""></p><h1 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h1><p>以日志的形式来记录每个写操作，将Redis执行过的所有<strong>写指令</strong>记录下来(读操作不记录)，<br>只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作，默认的文件名是appendonly.aof。</p><blockquote><p>rbd文件和aof文件可以共存</p></blockquote><h2 id="AOF的启动-修复-恢复"><a href="#AOF的启动-修复-恢复" class="headerlink" title="AOF的启动/修复/恢复"></a>AOF的启动/修复/恢复</h2><ul><li><strong>启动：</strong> 修改默认的<code>appendonly no</code>，改为yes</li><li><p><strong>修复：</strong> 当aof文件有损坏，可以使用命令进行修复，重启redis重新加载(修复前备份被写坏的AOF文件)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-check-aof --fix appendonly.aof</span><br></pre></td></tr></table></figure></li><li><p><strong>恢复：</strong> 将有数据的aof文件复制一份保存到对应目录<code>config get dir</code>，重启redis重新加载</p></li></ul><h2 id="Rewrite"><a href="#Rewrite" class="headerlink" title="Rewrite"></a>Rewrite</h2><p>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制,<br>当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，<br>只保留可以恢复数据的最小指令集.可以使用命令<code>bgrewriteaof</code></p><h3 id="重写原理"><a href="#重写原理" class="headerlink" title="重写原理"></a>重写原理</h3><p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似触发机制</p><h3 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h3><p>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发</p><h2 id="AOF的同步方式"><a href="#AOF的同步方式" class="headerlink" title="AOF的同步方式"></a>AOF的同步方式</h2><p>在配置文件中：</p><ul><li>每修改同步：<strong>appendfsync always</strong>   同步持久化 每次发生数据变更会被立即记录到磁盘  性能较差但数据完整性比较好</li><li>每秒同步：<strong>appendfsync everysec</strong>    异步操作，每秒记录   如果一秒内宕机，有数据丢失</li><li>不同步：<strong>appendfsync no</strong>   从不同步</li></ul><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><ul><li>相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb</li><li>aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同</li></ul><p><img src="http://coldwarm7.oss-cn-beijing.aliyuncs.com/18-10-10/47010611.jpg" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储</li><li>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些<br>命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.<br>Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大</li><li>只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式</li></ol><p><strong>同时开启两种持久化方式：</strong></p><ul><li><p>在这种情况下,<strong>当redis重启的时候会优先载入AOF文件来恢复原始的数据</strong>,<br>因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</p></li><li><p>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？</p><p>  建议不要，因为<strong>RDB更适合用于备份数据库</strong>(AOF在不断变化不好备份)，<br>快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</p></li></ul><p><strong>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化</strong> （默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p><p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分就是压缩格式不再是 AOF 格式，可读性较差。</p><hr><p>参考链接：</p><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.md" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/blob/master/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96.md</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;http://coldwarm7.oss-cn-beijing.aliyuncs.com/18-10-10/38280048.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="RDB" scheme="http://yoursite.com/tags/RDB/"/>
    
      <category term="AOF" scheme="http://yoursite.com/tags/AOF/"/>
    
  </entry>
  
  <entry>
    <title>nginx（一）</title>
    <link href="http://yoursite.com/2018/09/30/nginx%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/09/30/nginx（一）/</id>
    <published>2018-09-30T08:29:15.000Z</published>
    <updated>2018-09-30T08:39:55.136Z</updated>
    
    <content type="html"><![CDATA[<center><strong>nginx的安装以及server的配置</strong></center><a id="more"></a><h1 id="nginx的安装"><a href="#nginx的安装" class="headerlink" title="nginx的安装"></a>nginx的安装</h1><ol><li>直接在 <a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a>下载解压</li><li>运行nginx.exe即可</li><li>nginx默认端口号是80，直接打开网页 <a href="http://localhost/" target="_blank" rel="noopener">http://localhost/</a> ，看到下图的话就是启动成功</li></ol><p><img src="http://coldwarm7.oss-cn-beijing.aliyuncs.com/18-9-30/88823282.jpg" alt=""></p><ol start="4"><li>如果启动失败，那么一般就是80端口被占用，查找端口然后关闭进程就可以。</li></ol><blockquote><p>windows查找看所以端口号<code>netstat -ano</code>（或者直接<code>nestat -ano | findstr &quot;80&quot;</code>），找到80占用的端口号的PID，随后<code>tasklist | findstr &quot;PID&quot;</code>找到进程名字，然后去服务里面关掉（或者<code>taskkill /f /t /im [进程名称]</code>直接杀死进程即可）</p><blockquote><p>我在这里遇到的占用端口号查出来的占用进程是<code>System</code>，这个是服务里面的<code>SQL server Reporting Services</code>，直接关闭服务。</p></blockquote></blockquote><h1 id="nginx-的小demo"><a href="#nginx-的小demo" class="headerlink" title="nginx 的小demo"></a>nginx 的小demo</h1><ol><li>在E盘里面创建一个<code>E:\demo</code>文件夹，里面新建一个<code>index.html</code>的文件</li></ol><p><img src="http://coldwarm7.oss-cn-beijing.aliyuncs.com/18-9-30/44817483.jpg" alt=""></p><p>index.html:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;hello&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;helloword!&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;coldwarm777&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>打开安装nginx的文件夹里面的<code>conf\nginx.conf</code>,在<code>http</code>里面配置一个<code>server</code></li></ol><p><img src="http://coldwarm7.oss-cn-beijing.aliyuncs.com/18-9-30/73155296.jpg" alt=""></p><p>配置server：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#html文件     </span><br><span class="line">    server &#123;         </span><br><span class="line">        listen       8099;         </span><br><span class="line">        server_name  127.0.0.1 localhost;         </span><br><span class="line">        location / &#123;             </span><br><span class="line">            root   E:/demo ;             </span><br><span class="line">            index  index.html index.htm;         </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>cmd 进入Nginx解压目录 执行以下命令</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start nginx : 启动nginx服务</span><br><span class="line">nginx -s reload ：修改配置后重新加载生效</span><br><span class="line">nginx -s reopen ：重新打开日志文件</span><br><span class="line">nginx -t -c /path/to/nginx.conf 测试nginx配置文件是否正确</span><br></pre></td></tr></table></figure><ol start="4"><li>重新打开浏览器，输入<code>http://localhost:8099/</code></li></ol><p><img src="http://coldwarm7.oss-cn-beijing.aliyuncs.com/18-9-30/90172727.jpg" alt=""></p><h1 id="nginx配置文件"><a href="#nginx配置文件" class="headerlink" title="nginx配置文件"></a>nginx配置文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line">#user  nobody;</span><br><span class="line"> </span><br><span class="line">#指定nginx进程数</span><br><span class="line"> </span><br><span class="line">worker_processes  1;</span><br><span class="line"> </span><br><span class="line">#全局错误日志及PID文件</span><br><span class="line"> </span><br><span class="line">#error_log  logs/error.log;</span><br><span class="line"> </span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line"> </span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line"> </span><br><span class="line">#pid        logs/nginx.pid;</span><br><span class="line"> </span><br><span class="line">events &#123;</span><br><span class="line"> </span><br><span class="line">    # 连接数上限</span><br><span class="line"> </span><br><span class="line">    worker_connections  1024;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#设定http服务器，利用它的反向代理功能提供负载均衡支持</span><br><span class="line"> </span><br><span class="line">http &#123;</span><br><span class="line"> </span><br><span class="line">    #设定mime类型,类型由mime.type文件定义</span><br><span class="line"> </span><br><span class="line">    include       mime.types;</span><br><span class="line"> </span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"> </span><br><span class="line">    #设定日志格式</span><br><span class="line"> </span><br><span class="line">    #log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line"> </span><br><span class="line">    #                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line"> </span><br><span class="line">    #                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"> </span><br><span class="line">    #使用哪种格式的日志</span><br><span class="line"> </span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"> </span><br><span class="line">    #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用，    </span><br><span class="line"> </span><br><span class="line">    sendfile        on;</span><br><span class="line"> </span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"> </span><br><span class="line">    #连接超时时间</span><br><span class="line"> </span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line"> </span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"> </span><br><span class="line">    #开启gzip压缩 ，压缩html</span><br><span class="line"> </span><br><span class="line">    #gzip  on;</span><br><span class="line"> </span><br><span class="line">    #设定负载均衡的服务器列表 支持多组的负载均衡,可以配置多个upstream  来服务于不同的Server.</span><br><span class="line"> </span><br><span class="line">    #nginx 的 upstream 支持 几 种方式的分配</span><br><span class="line"> </span><br><span class="line">    #1)、轮询（默认） 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</span><br><span class="line"> </span><br><span class="line">    #2)、weight 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 跟上面样，指定了权重。</span><br><span class="line"> </span><br><span class="line">    #3)、ip_hash 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 </span><br><span class="line"> </span><br><span class="line">    #4)、fair      </span><br><span class="line"> </span><br><span class="line">    #5)、url_hash #Urlhash</span><br><span class="line"> </span><br><span class="line">    upstream mysvr &#123;</span><br><span class="line"> </span><br><span class="line">      #weigth参数表示权值，权值越高被分配到的几率越大   </span><br><span class="line"> </span><br><span class="line">      #1.down 表示单前的server暂时不参与负载</span><br><span class="line"> </span><br><span class="line">      #2.weight 默认为1.weight越大，负载的权重就越大。     </span><br><span class="line"> </span><br><span class="line">      #3.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。  </span><br><span class="line"> </span><br><span class="line">      #server 192.168.1.116  down;</span><br><span class="line"> </span><br><span class="line">      #server 192.168.1.116  backup;</span><br><span class="line"> </span><br><span class="line">      server 192.168.1.121  weight=1;</span><br><span class="line"> </span><br><span class="line">      server 192.168.1.122  weight=2;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    #配置代理服务器的地址，即Nginx安装的服务器地址、监听端口、默认地址</span><br><span class="line"> </span><br><span class="line">    server &#123;</span><br><span class="line"> </span><br><span class="line">        #1.侦听80端口</span><br><span class="line"> </span><br><span class="line">        listen       80;</span><br><span class="line"> </span><br><span class="line">        #对于server_name,如果需要将多个域名的请求进行反向代理，可以配置多个server_name来满足要</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        #charset koi8-r;</span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line">        location / &#123;</span><br><span class="line"> </span><br><span class="line">            # 默认主页目录在nginx安装目录的html子目录。</span><br><span class="line"> </span><br><span class="line">            root   html;</span><br><span class="line"> </span><br><span class="line">            index  index.html index.htm;           </span><br><span class="line"> </span><br><span class="line">            proxy_pass http://mysvr; #跟载均衡服务器的upstream对应   </span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line"> </span><br><span class="line">        ## 定义错误提示页面</span><br><span class="line"> </span><br><span class="line">        #error_page   500 502 503 504  /50x.html;</span><br><span class="line"> </span><br><span class="line">        #location = /50x.html &#123;</span><br><span class="line"> </span><br><span class="line">        #    root   html;</span><br><span class="line"> </span><br><span class="line">        #&#125;</span><br><span class="line"> </span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line"> </span><br><span class="line">        #</span><br><span class="line"> </span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line"> </span><br><span class="line">        #    proxy_pass   http://127.0.0.1;</span><br><span class="line"> </span><br><span class="line">        #&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line"> </span><br><span class="line">        #</span><br><span class="line"> </span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line"> </span><br><span class="line">        #    root           html;</span><br><span class="line"> </span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line"> </span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line"> </span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line"> </span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line"> </span><br><span class="line">        #&#125;</span><br><span class="line"> </span><br><span class="line">        # deny access to .htaccess files, if Apache&apos;s document root</span><br><span class="line"> </span><br><span class="line">        # concurs with nginx&apos;s one</span><br><span class="line"> </span><br><span class="line">        #</span><br><span class="line"> </span><br><span class="line">        #location ~ /\.ht &#123;</span><br><span class="line"> </span><br><span class="line">        #    deny  all;</span><br><span class="line"> </span><br><span class="line">        #&#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line"> </span><br><span class="line">    #</span><br><span class="line"> </span><br><span class="line">    #server &#123;</span><br><span class="line"> </span><br><span class="line">    #    listen       8000;</span><br><span class="line"> </span><br><span class="line">    #    listen       somename:8080;</span><br><span class="line"> </span><br><span class="line">    #    server_name  somename  alias  another.alias;</span><br><span class="line"> </span><br><span class="line">    #    location / &#123;</span><br><span class="line"> </span><br><span class="line">    #        root   html;</span><br><span class="line"> </span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line"> </span><br><span class="line">    #    &#125;</span><br><span class="line"> </span><br><span class="line">    #&#125;</span><br><span class="line"> </span><br><span class="line">    # HTTPS server</span><br><span class="line"> </span><br><span class="line">    #</span><br><span class="line"> </span><br><span class="line">    #server &#123;</span><br><span class="line"> </span><br><span class="line">    #    listen       443 ssl;</span><br><span class="line"> </span><br><span class="line">    #    server_name  localhost;</span><br><span class="line"> </span><br><span class="line">    #    ssl_certificate      cert.pem;</span><br><span class="line"> </span><br><span class="line">    #    ssl_certificate_key  cert.key;</span><br><span class="line"> </span><br><span class="line">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class="line"> </span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line"> </span><br><span class="line">    #    ssl_prefer_server_ciphers  on;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    #    location / &#123;</span><br><span class="line"> </span><br><span class="line">    #        root   html;</span><br><span class="line"> </span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line"> </span><br><span class="line">    #    &#125;</span><br><span class="line"> </span><br><span class="line">    #&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>本文参考：</p><p><a href="https://blog.csdn.net/kingscoming/article/details/79042874" target="_blank" rel="noopener">https://blog.csdn.net/kingscoming/article/details/79042874</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;strong&gt;nginx的安装以及server的配置&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="nginx" scheme="http://yoursite.com/categories/nginx/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>mysql与B树和B+树</title>
    <link href="http://yoursite.com/2018/09/22/mysql%E4%B8%8EB%E6%A0%91%E5%92%8CB-%E6%A0%91/"/>
    <id>http://yoursite.com/2018/09/22/mysql与B树和B-树/</id>
    <published>2018-09-22T09:54:27.000Z</published>
    <updated>2018-09-22T09:57:51.840Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://coldwarm7.oss-cn-beijing.aliyuncs.com/18-9-22/56496845.jpg" alt=""></p><center><strong>B树与B+树的直观区别</strong></center><a id="more"></a><h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><h2 id="B树-多路平衡查找树-的由来"><a href="#B树-多路平衡查找树-的由来" class="headerlink" title="B树(多路平衡查找树)的由来"></a>B树(多路平衡查找树)的由来</h2><p>在大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的（如果元素数量非常多的话，查找就退化成节点内部的线性查找了），这样导致<strong>二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下</strong></p><p>这样我们就提出了一个新的查找树结构——<strong>多路查找树</strong>。根据平衡二叉树的启发，自然就想到平衡多路查找树结构，也就是这篇文章所要阐述的第一个主题B~tree，即B树结构(后面，我们将看到，B树的各种操作能使B树保持较低的高度，从而达到有效避免磁盘过于频繁的查找存取操作，从而有效提高查找效率)。</p><h2 id="B树与红黑树最大的不同："><a href="#B树与红黑树最大的不同：" class="headerlink" title="B树与红黑树最大的不同："></a>B树与红黑树最大的不同：</h2><p>B树的结点可以有许多子女，从几个到几千个。那为什么又说B树与红黑树很相似呢?因为与红黑树一样，一棵含n个结点的B树的高度也为O（lgn），但可能比一棵红黑树的高度小许多，应为它的分支因子比较大。所以，B树可以在O（logn）时间内，实现各种如插入（insert），删除（delete）等动态集合操作。</p><h3 id="B树："><a href="#B树：" class="headerlink" title="B树："></a>B树：</h3><p><img src="http://img.my.csdn.net/uploads/201106/7/8394323_13074405906V6Q.jpg" alt=""></p><p>B树事实上是一种平衡的多叉查找树，也就是说<strong>最多可以开m个叉（m&gt;=2），我们称之为m阶b树</strong></p><blockquote><p>m阶数从下图来看其实就是一个子树最多有几个箭头分叉，或者说最多有m个子树</p></blockquote><p><img src="http://jbcdn2.b0.upaiyun.com/2016/09/02d18ce40581196332ee0327ee06d340.png" alt=""></p><h2 id="m阶B树满足以下条件："><a href="#m阶B树满足以下条件：" class="headerlink" title="m阶B树满足以下条件："></a>m阶B树满足以下条件：</h2><ul><li>每个节点至多可以拥有m棵子树</li><li>根节点，只有至少有2个节点（要么极端情况，就是一棵树就一个根节点，单细胞生物，即是根，也是叶，也是树)。</li><li>非根非叶的节点至少有的Ceil(m/2)个子树(<strong>Ceil表示向上取整，图中5阶B树，每个节点至少有3个子树，也就是至少有3个叉</strong>)</li><li>非叶节点中的信息包括[n,A0,K1,A1,K2,A2,…,Kn,An]，，其中n表示该节点中保存的关键字个数，K为关键字且Ki&lt;Ki+1，A为指向子树根节点的指针</li><li>从根到叶子的每一条路径都有相同的长度，也就是说，叶子节在相同的层，并且这些节点不带信息，实际上这些节点就表示找不到指定的值，也就是指向这些节点的指针为空</li></ul><blockquote><p><strong>每个节点中的关键字和左右子树都是有序的</strong></p><blockquote><p>有j个孩子的非叶子节点恰好有j-1个关键字，增序排列</p></blockquote></blockquote><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><p><strong>B+树与B树的差异在于</strong></p><ul><li><p>有n棵子树的节点含有n个关键字（也有认为是n-1个关键字）</p></li><li><p><strong>所有的叶子节点包含了全部的关键字</strong>，及指向含这些关键字记录的指针，且叶子节点本身根据关键字自小而大顺序连接。(而B 树的叶子节点并没有包括全部需要查找的信息)</p></li><li><p><strong>非叶子节点可以看成索引部分</strong>，节点中仅含有其子树（根节点）中的最大（或最小）关键字</p></li></ul><p><strong>通俗来讲有这两个区别：</strong></p><ul><li>在B树中，你可以将键和值存放在内部节点和叶子节点，但在B+树中，内部节点都是键，没有值。叶子节点同时存放键和值</li><li>B+树的叶子节点有一条链相连，而B+树的叶子节点各自独立。</li></ul><p><img src="http://img.my.csdn.net/uploads/201106/7/8394323_1307440587b6WG.jpg" alt=""></p><h2 id="B-树的查找过程"><a href="#B-树的查找过程" class="headerlink" title="B+树的查找过程"></a>B+树的查找过程</h2><p>与B树类似，只不过查找时，<strong>如果在非叶子节点上的关键字等于给定值，并不终止，而是继续沿着指针直到叶子节点位置</strong>。因此在B+树，不管查找成功与否，每次查找都是走了一条从根到叶子节点的路径.</p><blockquote><p>因为在上面说过了，B+树的非叶子节点可以看成索引的一部分，，例如哪怕在第二层找到10，但是还是会继续向下查找，直到找到叶子节点上的10。</p></blockquote><h1 id="mysql与B树和B-树"><a href="#mysql与B树和B-树" class="headerlink" title="mysql与B树和B+树"></a>mysql与B树和B+树</h1><p>在MySQL数据库中，诸多存储引擎使用的是B+树，即便其名字看上去是BTREE。</p><h2 id="innodb的索引机制"><a href="#innodb的索引机制" class="headerlink" title="innodb的索引机制"></a>innodb的索引机制</h2><p>先以innodb存储引擎为例，说明innodb引擎是如何利用B+树建立索引的</p><p>首先创建一张表：zodiac，并插入一些数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `zodiac` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` char(4) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `index_name` (`name`)</span><br><span class="line">); </span><br><span class="line"> </span><br><span class="line">insert zodiac(id,name) values(1,&apos;鼠&apos;); &amp;nbsp;</span><br><span class="line">insert zodiac(id,name) values(2,&apos;牛&apos;); &amp;nbsp;</span><br><span class="line">insert zodiac(id,name) values(3,&apos;虎&apos;); &amp;nbsp;</span><br><span class="line">insert zodiac(id,name) values(4,&apos;兔&apos;); &amp;nbsp;</span><br><span class="line">insert zodiac(id,name) values(5,&apos;龙&apos;); &amp;nbsp;</span><br><span class="line">insert zodiac(id,name) values(6,&apos;蛇&apos;); &amp;nbsp;</span><br><span class="line">insert zodiac(id,name) values(7,&apos;马&apos;); &amp;nbsp;</span><br><span class="line">insert zodiac(id,name) values(8,&apos;羊&apos;); &amp;nbsp;</span><br><span class="line">insert zodiac(id,name) values(9,&apos;猴&apos;);</span><br><span class="line">insert zodiac(id,name) values(10,&apos;鸡&apos;); &amp;nbsp;</span><br><span class="line">insert zodiac(id,name) values(11,&apos;狗&apos;); &amp;nbsp;</span><br><span class="line">insert zodiac(id,name) values(12,&apos;猪&apos;);</span><br></pre></td></tr></table></figure><p>对于innodb来说，只有一个数据文件，<strong>这个数据文件本身就是用B+树形式组织，B+树每个节点的关键字就是表的主键</strong>，因此innode的数据文件本身就是主索引文件，如下图所示，主索引中的叶子页（leaf page）包含了数据记录，但非叶子节点只包含了主键，术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起，因此这种索引被称为<strong>聚簇索引</strong>，或聚集索引。</p><p>这种索引方式，可以提高数据访问的速度，因为索引和数据是保存在同一棵B树之中，从聚簇索引中获取数据通常比在非聚簇索引中要来得快。</p><p>所以可以说，<strong>innodb的数据文件是依靠主键组织起来的，这也就是为什么innodb引擎下创建的表，必须指定主键的原因，如果没有显式指定主键，innodb引擎仍然会对该表隐式地定义一个主键作为聚簇索引。</strong></p><p><img src="http://jbcdn2.b0.upaiyun.com/2016/09/753de70b140d036e01b63fe64dcc859a.png" alt=""></p><p>同样innodb的辅助索引，如下图所示，假设这些字符是按照生肖的顺序排列的，其叶子节点中也包含了记录的主键，因此innodb引擎在查询辅助索引的时候会查询两次，首先通过辅助索引得到主键值，然后再查询主索引</p><p><img src="http://jbcdn2.b0.upaiyun.com/2016/09/5500c9fbdc2fb883b2f2738b9b253994.png" alt=""></p><h2 id="MyISAM的索引机制"><a href="#MyISAM的索引机制" class="headerlink" title="MyISAM的索引机制"></a>MyISAM的索引机制</h2><p>MyISAM引擎同样也使用B+树组织索引，如下图所示，假设我们的数据不是按照之前的顺序插入的，而是按照图中的是顺序插入表，可以看到MyISAM引擎下，<strong>B+树叶子节点中包含的是数据记录的地址（可以简单理解为“行号”），而MyISAM的辅助索引在结构上和主索引没有本质的区别，同样其叶子节点也包含了数据记录的地址</strong>，稍微不同的是辅助索引的关键字是允许重复</p><p><img src="http://coldwarm7.oss-cn-beijing.aliyuncs.com/18-9-22/98484869.jpg" alt=""></p><p><img src="http://coldwarm7.oss-cn-beijing.aliyuncs.com/18-9-22/23725435.jpg" alt=""></p><h1 id="总结与一些对比思考"><a href="#总结与一些对比思考" class="headerlink" title="总结与一些对比思考"></a>总结与一些对比思考</h1><h2 id="关于MyISAM和InnoDB两种引擎与-非-聚簇索引"><a href="#关于MyISAM和InnoDB两种引擎与-非-聚簇索引" class="headerlink" title="关于MyISAM和InnoDB两种引擎与(非)聚簇索引"></a>关于MyISAM和InnoDB两种引擎与(非)聚簇索引</h2><p><strong>MyISAM采用的是非聚簇索引，查找慢，增删快；InnoDB采用的聚簇索引，查找快，增删慢</strong></p><ul><li>MyISAM的非聚簇索引中，B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址，在增删中只要在叶子节点中增加data，也就是数据存放的地址就可以。而在查询中，查到叶子节点中的数据存放地址，还要根据地址在进行一次查询，所以查询慢。</li><li>InnoDb的聚簇索引中，数据记录是保存在B+树的叶子节点（大小相当于磁盘上的页）上，当插入新的数据时，如果主键的值是有序的，它会把每一条记录都存储在上一条记录的后面，但是如果主键使用的是无序的数值，例如UUID，这样在插入数据时Innodb无法简单地把新的数据插入到最后，而是需要为这条数据寻找合适的位置，这就额外增加了工作，这就是innodb引擎写入性能要略差于MyISAM的原因之一。</li></ul><h2 id="通俗来讲B树和B-树的区别"><a href="#通俗来讲B树和B-树的区别" class="headerlink" title="通俗来讲B树和B+树的区别"></a>通俗来讲B树和B+树的区别</h2><ul><li>在B树中，你可以将键和值存放在内部节点和叶子节点，但在B+树中，内部节点都是键，没有值。叶子节点同时存放键和值</li><li>B+树的叶子节点有一条链相连，而B+树的叶子节点各自独立。</li></ul><h2 id="使用B-树的好处"><a href="#使用B-树的好处" class="headerlink" title="使用B+树的好处"></a>使用B+树的好处</h2><ul><li>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。</li><li>B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</li></ul><h2 id="使用B树的好处"><a href="#使用B树的好处" class="headerlink" title="使用B树的好处"></a>使用B树的好处</h2><p>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</p><h2 id="数据库为什么使用B-树而不是B树"><a href="#数据库为什么使用B-树而不是B树" class="headerlink" title="数据库为什么使用B+树而不是B树"></a>数据库为什么使用B+树而不是B树</h2><p>因为就是上面提到的B+树的好处。数据库的数据读取都是需要进行代价巨大的磁盘IO操作，因此，更快地缩小范围和更少的读取次数是数据库需要关注的重点。而B+树在这些点上比B树做的更好。这就是为什么数据库要选用B+树作为底层实现。</p><hr><p>参考文章：</p><p><a href="http://blog.jobbole.com/105644/" target="_blank" rel="noopener">http://blog.jobbole.com/105644/</a></p><p><a href="https://blog.csdn.net/zhoucheng05_13/article/details/79825246" target="_blank" rel="noopener">https://blog.csdn.net/zhoucheng05_13/article/details/79825246</a></p><p><a href="https://blog.csdn.net/lisuyibmd/article/details/53004848" target="_blank" rel="noopener">https://blog.csdn.net/lisuyibmd/article/details/53004848</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://coldwarm7.oss-cn-beijing.aliyuncs.com/18-9-22/56496845.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;B树与B+树的直观区别&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="MyISAN" scheme="http://yoursite.com/tags/MyISAN/"/>
    
      <category term="InnoDB" scheme="http://yoursite.com/tags/InnoDB/"/>
    
  </entry>
  
  <entry>
    <title>面试回顾（二）</title>
    <link href="http://yoursite.com/2018/09/21/%E9%9D%A2%E8%AF%95%E5%9B%9E%E9%A1%BE%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/09/21/面试回顾（二）/</id>
    <published>2018-09-20T16:00:53.000Z</published>
    <updated>2018-09-20T16:31:57.674Z</updated>
    
    <content type="html"><![CDATA[<center><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fu71gciusmj30xc0kmkah.jpg" alt=""></center><a id="more"></a><ol><li>平衡二叉树，满二叉树</li><li>冒泡和快排算法思想</li></ol><h3 id="3-mysql和postgrsql区别"><a href="#3-mysql和postgrsql区别" class="headerlink" title="3. mysql和postgrsql区别"></a>3. mysql和postgrsql区别</h3><ul><li>pg性能优于mysql,相同的数据量计算，pg时间一般只有mysql的四分之一左右（具体情况可能有所不同）</li><li>.pg对json支持比较好，还有fdw功能，可以吧别的数据库的表当自己的用 </li><li>任何系统都有它的性能极限，在高并发读写，负载逼近极限下，PG的性能指标仍可以维持双曲线甚至对数曲线，到顶峰之后不再下降，而 MySQL 明显出现一个波峰后下滑（5.5版本之后，在企业级版本中有个插件可以改善很多，不过需要付费）。 </li><li>mysql的innodb引擎，可以充分优化利用系统所有内存，超大内存下PG对内存使用的不那么充分 </li><li>MySQL使用了线程，而PostgreSQL使用的是进程。在不同线程之间的环境转换和访问公用的存储区域显然要比在不同的进程之间要快得多。</li></ul><blockquote><p>参考链接<a href="https://www.biaodianfu.com/mysql-vs-postgresql.html" target="_blank" rel="noopener">https://www.biaodianfu.com/mysql-vs-postgresql.html</a></p></blockquote><h3 id="4-jpa和mybatis区别，适用于什么情况"><a href="#4-jpa和mybatis区别，适用于什么情况" class="headerlink" title="4. jpa和mybatis区别，适用于什么情况"></a>4. jpa和mybatis区别，适用于什么情况</h3><p>在面试中面试官提了这样一个问题，Springboot项目在开发的过程中可能会用到两个数据库，例如mysql和Postgresql，那么Jpa和Mybatis应该如何选择？</p><p>hibernate是完备的ORM框架，是符合JPA规范的，但Mybatis不是。Mybatis相比单纯的写JDBC肯定是方便一点，但是无可避免的还是要写SQL，且无法做到垮数据库。 <strong>而hibernate使用JPA就可以无需考虑数据库的兼容性问题</strong></p><p>使用 Hibernate 的一个难点是，如何来设计对象之间的关系。如果是关系型数据库的话，表和表是通过外键来进行关联的。而在 ORM 中，则需要从面向对象的角度出发，来设计对象之间的关联关系。这个是需要思路上做一个转变的。</p><p>很多人青睐 Mybatis ，原因是其提供了<strong>便利的 SQL 操作，自由度高，封装性好</strong>……<strong>SpringData JPA对复杂 SQL 的支持不好</strong>，没有实体关联的两个表要做 join ，的确要花不少功夫。但 SpringData JPA 并不把这个当做一个问题。为什么？因为<strong>现代微服务的架构，各个服务之间的数据库是隔离的</strong>，跨越很多张表的 join 操作本就不应该交给单一的业务数据库去完成。解决方案是：使用 elasticSearch做视图查询 或者 mongodb 一类的Nosql 去完成。问题本不是问题。</p><blockquote><p>jpa的学习成本高于Mybatis</p></blockquote><ol start="5"><li>手动在linux上部署springboot项目</li><li>进程线程区别</li><li>http方法</li><li>osi七层模型</li></ol><h3 id="9-ArrayList和LinkedList区别"><a href="#9-ArrayList和LinkedList区别" class="headerlink" title="9. ArrayList和LinkedList区别"></a>9. ArrayList和LinkedList区别</h3><p>最大的区别是底层实现，ArrayList基于数组，LinkedList基于链表，数组各元素内存是连续的，进行随机访问时效率很高，需要扩容，链表不需要扩容。数组在每次插入和删除中间的元素时都需要将后续的元素进行移动，而链表不需要，所以当存多于取使用链表，当取多于存时使用数组</p><h3 id="10-SpringBoot和Spring-mvc区别"><a href="#10-SpringBoot和Spring-mvc区别" class="headerlink" title="10. SpringBoot和Spring mvc区别"></a>10. SpringBoot和Spring mvc区别</h3><p><strong>约定优于配置</strong>，简化了spring的配置流程。</p><p>Spring MVC和Spring Boot都属于Spring，Spring MVC 是基于Spring的一个 MVC 框架，而Spring Boot 是基于Spring的一套快速开发整合包</p><ol start="11"><li>NIO</li></ol><h3 id="12-http和https的常用端口号"><a href="#12-http和https的常用端口号" class="headerlink" title="12. http和https的常用端口号"></a>12. http和https的常用端口号</h3><pre><code>- http：80- https：443/tcp 443/udp- mysql 3306- tomcat 8080- SOCKS代理协议服务器常用端口号：1080 - TP（文件传输）协议代理服务器常用端口号：21 - Telnet（远程登录）协议代理服务器常用端口：23</code></pre><h3 id="13-查看进程"><a href="#13-查看进程" class="headerlink" title="13. 查看进程"></a>13. 查看进程</h3><pre><code>- windows如何终止进程：cmd ---&gt;&gt;&gt;&gt; netstat -aon|findstr 1099查看进行pidtaskkill -f -pid 5608杀死进程- mac终止进程：ps aux | grep postgressudo kill</code></pre><h3 id="14-sql的是怎么实现预编译防止sql注入攻击"><a href="#14-sql的是怎么实现预编译防止sql注入攻击" class="headerlink" title="14. sql的是怎么实现预编译防止sql注入攻击"></a>14. sql的是怎么实现预编译防止sql注入攻击</h3><p>使用PrepareStatement，可以防止sql注入攻击，sql的执行需要编译，注入问题之所以出现，是因为用户填写 sql语句参与了编译。使用PrepareStatement对象在执行sql语句时，会分为两步，第一步将sql语句 “运送” 到mysql上预编译，再回到java端拿到参数运送到mysql端。<strong>预先编译好，也就是SQL引擎会预先进行语法分析，产生语法树，生成执行计划，也就是说，后面你输入的参数，无论你输入的是什么，都不会影响该sql语句的语法结构了。用户填写的 sql语句，就不会参与编译，只会当做参数来看。从而避免了sql注入问题</strong>。</p><h3 id="15-如何理解微服务"><a href="#15-如何理解微服务" class="headerlink" title="15. 如何理解微服务"></a>15. 如何理解微服务</h3><ul><li>一系列微小的服务共同组成</li><li>单独部署，跑在自己的进程里</li><li>每个服务为独立的业务开发</li><li>分布式的管理</li><li>微服务开发是产品模式，团队的成员负责整个项目的生命周期</li></ul><p><strong>优点</strong></p><ul><li>易于开发： 开发方式简单，IDE 支持好，方便运行和调试。</li><li>易于测试： 所有功能运行在一个进程中，一旦进程启动，便可以进行系统测试。</li><li>易于部署： 只需要将打好的一个软件包发布到服务器即可。</li><li>易于水平伸缩： 只需要创建一个服务器节点，配置好运行时环境，再将软件包发布到新服务器节点即可运行程序（当然也需要采取分发策略保证请求能有效地分发到新节点）。</li></ul><p><strong>缺点</strong></p><ul><li>维护成本大： 当应用程序的功能越来越多、团队越来越大时，沟通成本、管理成本显著增加。当出现 bug 时，可能引起 bug 的原因组合越来越多，导致分析、定位和修复的成本增加；并且在对全局功能缺乏深度理解的情况下，容易在修复 bug 时引入新的 bug。</li><li>持续交付周期长： 构建和部署时间会随着功能的增多而增加，任何细微的修改都会触发部署流水线。</li><li>新人培养周期长： 新成员了解背景、熟悉业务和配置环境的时间越来越长。</li><li>技术选型成本高： 单块架构倾向于采用统一的技术平台或方案来解决所有问题，如果后续想引入新的技术或框架，成本和风险都很大。</li><li>可扩展性差： 随着功能的增加，垂直扩展的成本将会越来越大；而对于水平扩展而言，因为所有代码都运行在同一个进程，没办法做到针对应用程序的部分功能做独立的扩展。</li></ul><blockquote><p>更多关于微服务的理解推荐这篇博文： <a href="https://www.jianshu.com/p/bc0003b52518" target="_blank" rel="noopener">https://www.jianshu.com/p/bc0003b52518</a></p></blockquote><h3 id="16-如何理解敏捷编程"><a href="#16-如何理解敏捷编程" class="headerlink" title="16. 如何理解敏捷编程"></a>16. 如何理解敏捷编程</h3><p><strong>敏捷开发的特征</strong></p><ul><li>迭代式开发（持续交付新版本软件）</li><li>增量交付</li><li>开发团队和用户反馈推动产品开发</li><li>持续集成</li><li>开发团队自我管理（面对面的沟通）</li></ul><p><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fvgg4mepscj30mo0ataeg.jpg" alt=""></p><blockquote><p>关于敏捷开发的理解推荐：<a href="https://juejin.im/post/5abc5ecc6fb9a028c14a885d" target="_blank" rel="noopener">https://juejin.im/post/5abc5ecc6fb9a028c14a885d</a></p></blockquote><h3 id="17-如何理解Restful"><a href="#17-如何理解Restful" class="headerlink" title="17.如何理解Restful"></a>17.如何理解Restful</h3><p><strong>Representation State Transfer</strong> : 直译为表现层状态转移.</p><p>是通过HTTP协议来描述Web API的约定风格.</p><p>服务端面向Web的API需要通过HTTP协议来表达.了解一下REST的起源可以知道其作者是HTTP协议的制定者,所以HTTP协议的语义元素天然符合REST的约束要求.</p><p>但RESTful并不是强制的,Web API不必遵循RESTful,但是遵循RESTful可以令API表达的语义更简单清晰统一,在语义全部抽象为转台转移后,分布式系统的架构关注点(维护状态一致)也会更明确.</p><p><strong>初步理解并运用restful</strong></p><ul><li>使用METHOD (POST,DELETE,GET,PUT) 等动词表示増删查改四种操作.</li><li>使用URI(通常是其子集URL)来表示对象或资源.</li><li>使用queryString表示查询输入</li><li>使用body表示更新和保存的状态输入</li><li>使用HEAD进行扩展</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0068YiZcgy1fu71gciusmj30xc0kmkah.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="java，面试" scheme="http://yoursite.com/tags/java%EF%BC%8C%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>mysql数据库引擎相关</title>
    <link href="http://yoursite.com/2018/09/20/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2018/09/20/mysql数据库引擎相关/</id>
    <published>2018-09-20T15:34:21.000Z</published>
    <updated>2018-09-20T16:09:40.481Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fv9h6mh6vpj30nl0eftg0.jpg" alt=""></p><a id="more"></a><h2 id="Myisam引擎"><a href="#Myisam引擎" class="headerlink" title="Myisam引擎"></a>Myisam引擎</h2><p>MyISAM基于ISAM存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入、查询速度，<strong>但不支持事务</strong>。</p><p><strong>MyISAM主要特性</strong>有： </p><ol><li>不支持行锁(MyISAM只有表锁)，读取时对需要读到的所有表加锁，写入时则对表加排他锁；</li><li>不支持事务</li><li>不支持外键</li><li>不支持崩溃后的安全恢复</li><li>在表有读取查询的同时，支持往表中插入新纪录</li><li>支持BLOB和TEXT的前500个字符索引，支持全文索引</li><li>支持延迟更新索引，极大地提升了写入性能</li><li>对于不会进行修改的表，支持 压缩表 ，极大地减少了磁盘空间的占用</li></ol><blockquote><p>聚簇索引(也叫聚集索引)指的是物理地址是连续的，非聚簇索引相反</p></blockquote><blockquote><p>Mysql的<strong>行锁和表锁</strong>（ 锁是计算机协调多个进程或纯线程并发访问某一资源的机制）<br>表级锁： 每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；<br>行级锁： 每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；</p></blockquote><p><strong>下图是MyISAM索引的原理图:</strong></p><p><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fv9h157f9ij30id0e5my1.jpg" alt=""></p><h2 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h2><p>InnoDB的主要特性：</p><ol><li>支持行锁，采用MVCC来支持高并发，有可能死锁</li><li>支持事务</li><li>支持外键</li><li>支持崩溃后的安全恢复</li><li>不支持全文索引</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>MyISAM更适合读密集的表，而InnoDB更适合写密集的的表。</strong></p><p>在数据库做主从分离的情况下，经常选择MyISAM作为主库的存储引擎。</p><p>一般来说，如果需要事务支持，并且有较高的并发读取频率(MyISAM的表锁的粒度太大，所以当该表写并发量较高时，要等待的查询就会很多了)，InnoDB是不错的选择。如果你的数据量很大（MyISAM支持压缩特性可以减少磁盘的空间占用），而且不需要支持事务时，MyISAM是最好的选择。</p><hr><p>参考链接：</p><p><a href="https://blog.csdn.net/xiaoquantouer/article/details/71036439" target="_blank" rel="noopener">https://blog.csdn.net/xiaoquantouer/article/details/71036439</a></p><p><a href="https://juejin.im/post/5b1685bef265da6e5c3c1c34" target="_blank" rel="noopener">https://juejin.im/post/5b1685bef265da6e5c3c1c34</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0068YiZcgy1fv9h6mh6vpj30nl0eftg0.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="MyISAN" scheme="http://yoursite.com/tags/MyISAN/"/>
    
      <category term="InnoDB" scheme="http://yoursite.com/tags/InnoDB/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="http://yoursite.com/2018/09/20/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://yoursite.com/2018/09/20/红黑树/</id>
    <published>2018-09-20T15:29:15.000Z</published>
    <updated>2018-09-20T16:10:02.441Z</updated>
    
    <content type="html"><![CDATA[<ol><li>每个结点要么是红的要么是黑的。  </li><li>根结点是黑的。  </li><li>每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。  </li><li>如果一个结点是红的，那么它的两个儿子都是黑的。  </li><li><p><strong>对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。</strong></p><p> 最近面试数据结构问的挺多的，回头复习一下。</p><a id="more"></a></li></ol><blockquote><p>所以在进行红黑树的自旋或者染色调整的时候，最好保证黑色的节点数量不变</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fvgb4lrotdj30sy0eagnp.jpg" alt=""></p><blockquote><p>红黑树的查找、插入、删除的时间复杂度最坏为O(log n)</p></blockquote><h2 id="红黑树平衡性的修正"><a href="#红黑树平衡性的修正" class="headerlink" title="红黑树平衡性的修正"></a>红黑树平衡性的修正</h2><p>红-黑树主要通过三种方式对平衡进行修正，改变节点颜色、左旋和右旋</p><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p>通常左旋操作用于将一个向右倾斜的红色链接旋转为向左链接</p><p><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fvgb8s9g29g309506pjxv.jpg" alt=""></p><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fvgbc9jhbmg308d076te7.jpg" alt=""></p><h3 id="自旋具体有这几种情况"><a href="#自旋具体有这几种情况" class="headerlink" title="自旋具体有这几种情况"></a>自旋具体有这几种情况</h3><ol><li>父亲节点和叔叔节点都是红色：</li></ol><p><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fvgem170mkj30nb09gmz2.jpg" alt=""></p><p>假设插入的是节点 N，这时父亲节点 P 和叔叔节点 U 都是红色，爷爷节点 G 一定是黑色。</p><ol start="2"><li>父亲节点为红色，叔叔节点为黑色：</li></ol><p><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fvgenpi5wqj30n408z0ui.jpg" alt=""></p><p>假设插入的是节点 N，这时父亲节点 P 是红色，叔叔节点 U 是黑色，爷爷节点 G 一定是黑色。</p><p>在这里我本来是有一个疑问的，问什么不把N节点直接染黑，后来发现如果直接染黑，那么相当于多出来一个黑色的节点，这有违红黑树的第五个特点。所以一般来说，红黑树插入的节点都是红色的。具体原因看下面。</p><p><strong>注意:</strong></p><p><strong>++在红-黑树中插入的节点都是红色的++</strong>，这不是偶然的，因为插入一个红色节点比插入一个黑色节点违背红-黑规则的可能性更小。原因是：插入黑色节点总会改变黑色高度（违背规则4），但是插入红色节点只有一半的机会会违背规则3。另外违背规则3比违背规则4要更容易修正。当插入一个新的节点时，可能会破坏这种平衡性，</p><ol start="3"><li>上面讲的是插入节点 N 在父亲节点 P 的左孩子位置，如果 N 是 P 的右孩子，就需要多进行一次左旋，把情况化解成上述情况。</li></ol><p><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fvgeu42w15j30n909i767.jpg" alt=""></p><h2 id="红黑树的删除与调整"><a href="#红黑树的删除与调整" class="headerlink" title="红黑树的删除与调整"></a>红黑树的删除与调整</h2><h3 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h3><ol><li>要删除的节点正好是叶子节点，直接删除就OK了</li></ol><p><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fvgf2owgjyj30h60853yw.jpg" alt=""></p><ol start="2"><li>有左孩子或者右孩子，直接把这个孩子上移放到要删除的位置就好了</li></ol><p><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fvgf4zb4h1j30je08dmxo.jpg" alt=""></p><ol start="3"><li>有两个孩子，就需要选一个合适的孩子节点作为新的根节点，该节点称为 继承节点</li></ol><p><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fvgf5h5r2aj30kv09x75f.jpg" alt=""></p><h3 id="删除后的调整"><a href="#删除后的调整" class="headerlink" title="删除后的调整"></a>删除后的调整</h3><p>根据红黑树的第 5 个特性：</p><p><strong>如果当前待删除节点是红色的，它被删除之后对当前树的特性不会造成任何破坏影响。<br>而如果被删除的节点是黑色的，这就需要进行进一步的调整来保证后续的树结构满足要求。</strong></p><p>这里研究的是删除黑色节点的情况。</p><p><strong>调整思想</strong></p><p>为了保证删除节点父亲节点左右两边黑色节点数一致，需要重点关注父亲节点没删除的那一边节点是不是黑色。如果删除后父亲节点另一边比删除的一边黑色节点多，就要想办法搞到平衡，具体的平衡方法有如下几种方法：</p><ol><li>把父亲节点另一边（即删除节点的兄弟树）其中一个节点弄成红色，也少一个黑色</li><li>或者把另一边多的黑色节点转过来一个</li></ol><p>删除节点在父亲节点的左子树还是右子树，调整方式都是对称的</p><hr><p>本文参考：<a href="https://juejin.im/entry/58371f13a22b9d006882902d" target="_blank" rel="noopener">https://juejin.im/entry/58371f13a22b9d006882902d</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;每个结点要么是红的要么是黑的。  &lt;/li&gt;
&lt;li&gt;根结点是黑的。  &lt;/li&gt;
&lt;li&gt;每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。  &lt;/li&gt;
&lt;li&gt;如果一个结点是红的，那么它的两个儿子都是黑的。  &lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 最近面试数据结构问的挺多的，回头复习一下。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树，数据结构" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JVM-虚拟机垃圾回收与内存分配</title>
    <link href="http://yoursite.com/2018/09/05/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>http://yoursite.com/2018/09/05/JVM-虚拟机垃圾回收与内存分配/</id>
    <published>2018-09-05T06:32:55.000Z</published>
    <updated>2018-09-05T08:09:11.996Z</updated>
    
    <content type="html"><![CDATA[<center><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fuynpaif3xj30hs08i3yn.jpg" alt=""></center><center><strong>如何判断对象死亡、引用、常用垃圾回收器</strong></center><a id="more"></a><h3 id="1-如何判断对象已经死亡？"><a href="#1-如何判断对象已经死亡？" class="headerlink" title="1. 如何判断对象已经死亡？"></a>1. 如何判断对象已经死亡？</h3><hr><h4 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 引用计数法</h4><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。</p><p>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</p><h4 id="1-2-可达性分析计算"><a href="#1-2-可达性分析计算" class="headerlink" title="1.2 可达性分析计算"></a>1.2 可达性分析计算</h4><p>这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明此对象是不可用的。</p><center><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fuynxexh4lj30lp0ddwk6.jpg" alt=""></center><p>上图中object5，6，7互相有关联，但是与GC roots没有关联，所以判定为可回收对象。</p><h4 id="1-3-引用"><a href="#1-3-引用" class="headerlink" title="1.3 引用"></a>1.3 引用</h4><p>JDK1.2以后，Java对引用的感念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p><p><strong>强引用(Strong Reference)</strong></p><p>在程序中大部分使用的都是强引用，例如<code>Object object = new Object;</code>这类引用，只要强引用还在，垃圾收集器就永远不会回收掉被引用的对象</p><p><strong>软引用(Soft Reference)</strong></p><p>用来描述还有用但并非必须的对象，对于软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围中进行二次回收，如果回收之后还没有足够的内存，才会抛出内存溢出异常。</p><p>软引用可用来实现内存敏感的告诉缓存。</p><p><strong>弱引用（WeakReference)</strong></p><p>用来描述非必须的对象，被弱引用关联的对象只能存活到下一次垃圾收集发生之前，比软引用拥有更短的生命周期。一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p><strong>虚引用（PhantomReference)</strong></p><p>最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。虚引用的唯一目的就是在 <strong>这个对象被收集器回收时收到一个系统通知</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong><br>虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为 <strong>软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。</strong></p><h4 id="1-4-如何判断对象已经死亡？"><a href="#1-4-如何判断对象已经死亡？" class="headerlink" title="1.4 如何判断对象已经死亡？"></a>1.4 如何判断对象已经死亡？</h4><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历 <strong>两次</strong>标记过程：</p><ul><li>可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize方法。当对象没有覆盖finalize方法，或finalize方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</li><li>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</li></ul><p><strong>finalize()方法与对象自救</strong></p><p>在判定对象是否有必要执行finalize()方法的时候，对象有且只有一次自我拯救的机会(<em>因为finalize方法只会执行一次</em>)，只要重新与引用链上的任何一个对象建立关联即可，例如将自己(this关键字)赋值给某个变量或者对象的成员变量，那么在第二次标记的时候它会被移除”即将回收” 的集合。</p><p>但事实上并不鼓励使用这种方法来拯救对象，因为他不是C/C++中的析构函数，而是java刚诞生时为了是C/C++程序员可以更好接受它的一种妥协方式，运行代价高，不确定性大，无法保证各个对象的调用顺序。</p><p><strong>finalize()所能做的工作，try-finally或者其他方式都可以做的更好，更及时。尽量避免使用finalize()方法。</strong></p><h4 id="1-5-回收方法区"><a href="#1-5-回收方法区" class="headerlink" title="1.5 回收方法区"></a>1.5 回收方法区</h4><p>方法区（或Hotspot虚拟中的永久代）的垃圾收集主要回收两部分内容：<strong>废弃常量和无用的类</strong>，收集效率较低。</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是 “无用的类” ：</p><ul><li><p>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</p></li><li><p>加载该类的ClassLoader已经被回收。</p></li><li><p>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p></li></ul><h3 id="2-垃圾收集算法"><a href="#2-垃圾收集算法" class="headerlink" title="2. 垃圾收集算法"></a>2. 垃圾收集算法</h3><hr><h4 id="2-1-标记-清除算法"><a href="#2-1-标记-清除算法" class="headerlink" title="2.1 标记-清除算法"></a>2.1 标记-清除算法</h4><p>算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，会带来两个明显的问题；1：效率问题和2：空间问题（标记清除后会产生大量不连续的碎片）</p><center><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fuyos72tfaj30ly0bvado.jpg" alt=""></center><h4 id="2-2-复制算法"><a href="#2-2-复制算法" class="headerlink" title="2.2 复制算法"></a>2.2 复制算法</h4><p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><center><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fuyotw0wfrj30my0bhq7z.jpg" alt=""></center><blockquote><p>但是事实上，复制算法的代价是将内存缩小了原来的一半，代价太高。现在的虚拟机大多采用分代收集算法来进行垃圾回收。这就是下面的2.4 分代收集算法</p></blockquote><h4 id="2-3-标记-整理算法"><a href="#2-3-标记-整理算法" class="headerlink" title="2.3 标记-整理算法"></a>2.3 标记-整理算法</h4><p>根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一段移动，然后直接清理掉端边界以外的内存。</p><center><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fuyp6b6ztyj30ma0c6jv8.jpg" alt=""></center><h4 id="2-4-分代收集算法"><a href="#2-4-分代收集算法" class="headerlink" title="2.4 分代收集算法"></a>2.4 分代收集算法</h4><p>当前虚拟机的垃圾手机都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的所以我们可以选择“标记-清理”或“标记-整理”算法进行垃圾收集。</p><center><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fuynpaif3xj30hs08i3yn.jpg" alt=""></center><p><strong>回收机制</strong></p><p>将内存划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和第一块Survivor<br>空间。当回收时，将这两块空间还存活的对象复制到第二块Survivor中，然后清理掉Eden和第一块Survivor空间，HotSpot虚拟机默认的Eden：Survivor1：Survivor2 = 8：1：1，所以每次新生代中的可用内存空间为整个新生代容量的90%。当复制到第二块Survivor中所需的内存超过10%的时候，会对老年代内存进行分配担保，多出来的对象就可以直接进入老年代。</p><h3 id="3-垃圾收集器"><a href="#3-垃圾收集器" class="headerlink" title="3. 垃圾收集器"></a>3. 垃圾收集器</h3><hr><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p><p>没有最好的垃圾收集器，只有根据应用场景选择合适自己的垃圾收集器</p><h4 id="3-1-Serial收集器"><a href="#3-1-Serial收集器" class="headerlink" title="3.1 Serial收集器"></a>3.1 Serial收集器</h4><p>Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” 了解一下），直到它收集结束。</p><center><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fuyps7az2fj30is04dwg1.jpg" alt=""></center><p>虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p><p>但是Serial收集器有没有优于其他垃圾收集器的地方呢？当然有，它 <strong>简单而高效</strong>（与其他收集器的单线程相比）。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是个不错的选择。</p><h4 id="3-2-ParNew收集器"><a href="#3-2-ParNew收集器" class="headerlink" title="3.2 ParNew收集器"></a>3.2 ParNew收集器</h4><p><strong>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。</strong></p><center><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fuypul22rzj30iu04gwg4.jpg" alt=""></center><p>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p><p><strong>并行和并发概念补充：</strong></p><ul><li><p>并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p></li><li><p>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个CPU上。</p></li></ul><h4 id="3-3-Parallel-Scavenge收集器"><a href="#3-3-Parallel-Scavenge收集器" class="headerlink" title="3.3 Parallel Scavenge收集器"></a>3.3 Parallel Scavenge收集器</h4><p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的的多线程收集器。。。那么它有什么特别之处呢？</p><p><strong>Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。</strong> Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><h4 id="3-4-Serial-Old收集器"><a href="#3-4-Serial-Old收集器" class="headerlink" title="3.4 Serial Old收集器"></a>3.4 Serial Old收集器</h4><p><strong>Serial收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。</p><h4 id="3-5-Parallel-Old收集器"><a href="#3-5-Parallel-Old收集器" class="headerlink" title="3.5 Parallel Old收集器"></a>3.5 Parallel Old收集器</h4><p>Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。</p><h4 id="3-6-CMS收集器"><a href="#3-6-CMS收集器" class="headerlink" title="3.6 CMS收集器"></a>3.6 CMS收集器</h4><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用。</strong></p><p>从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种 “ <strong>标记-清除</strong>”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><p>初始标记： 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 ；</p></li><li><p>并发标记： 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</p></li><li><p>重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</p></li><li><p>并发清除： 开启用户线程，同时GC线程开始对为标记的区域做清扫。</p></li></ul><center><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fuypz9hikpj30in04tmys.jpg" alt=""></center><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：</p><ul><li><p>对CPU资源敏感；</p></li><li><p>无法处理浮动垃圾；</p></li><li><p>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</p></li></ul><h4 id="3-7-G1收集器"><a href="#3-7-G1收集器" class="headerlink" title="3.7 G1收集器"></a>3.7 G1收集器</h4><p>上一代的垃圾收集器(串行serial, 并行parallel, 以及CMS)都把堆内存划分为固定大小的三个部分: 年轻代(young generation), 年老代(old generation), 以及持久代(permanent generation).</p><p><strong>G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p><p>被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点：</p><ul><li><p>并行与并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</p></li><li><p>分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。</p></li><li><p>空间整合：与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</p></li><li><p>可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1和ＣＭＳ共同的关注点，但Ｇ１除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。</p></li></ul><p><strong>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)</strong>。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><p>G1收集器的运作大致分为以下几个步骤：</p><ul><li><p>初始标记</p></li><li><p>并发标记</p></li><li><p>最终标记</p></li><li><p>筛选回收</p></li></ul><p>上面几个步骤的运作过程和CMS有很多相似之处。初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS的值，让下一个阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这一阶段需要停顿线程，但是耗时很短，并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段时耗时较长，但可与用户程序并发执行。而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remenbered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这一阶段需要停顿线程，但是可并行执行。最后在筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。</p><center><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fuyq2h28lwj30iq04mq4o.jpg" alt=""></center><h3 id="4-内存分配和回收策略"><a href="#4-内存分配和回收策略" class="headerlink" title="4. 内存分配和回收策略"></a>4. 内存分配和回收策略</h3><h4 id="4-1-对象优先在Eden区分配"><a href="#4-1-对象优先在Eden区分配" class="headerlink" title="4.1 对象优先在Eden区分配"></a>4.1 对象优先在Eden区分配</h4><p>大多数情况下，对象在新生代中Eden区分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC.</p><p><strong>Minor Gc和Full GC 有什么不同呢？</strong></p><ul><li><p>新生代GC（Minor GC）:指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。</p></li><li><p>老年代GC（Major GC/Full GC）:指发生在老年代的GC，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上。</p></li></ul><h4 id="4-2-大对象直接进入老年代"><a href="#4-2-大对象直接进入老年代" class="headerlink" title="4.2 大对象直接进入老年代"></a>4.2 大对象直接进入老年代</h4><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p><h4 id="4-3-长期存活的对象进入老年代"><a href="#4-3-长期存活的对象进入老年代" class="headerlink" title="4.3 长期存活的对象进入老年代"></a>4.3 长期存活的对象进入老年代</h4><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别那些对象应放在新生代，那些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p><h4 id="4-4-动态对象年龄判断"><a href="#4-4-动态对象年龄判断" class="headerlink" title="4.4 动态对象年龄判断"></a>4.4 动态对象年龄判断</h4><p>为了更好的适应不同程序的内存情况，虚拟机不是永远要求对象年龄必须达到了某个值才能进入老年代，如果Survivor 空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需达到要求的年龄。</p><hr><p>本文参考：</p><ul><li>《深入理解JAVA虚拟机》第二版</li><li><a href="https://github.com/Snailclimb/Java-Guide" target="_blank" rel="noopener">https://github.com/Snailclimb/Java-Guide</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0068YiZcgy1fuynpaif3xj30hs08i3yn.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;center&gt;&lt;strong&gt;如何判断对象死亡、引用、常用垃圾回收器&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM-虚拟机类加载机制</title>
    <link href="http://yoursite.com/2018/09/04/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/09/04/JVM-虚拟机类加载机制/</id>
    <published>2018-09-04T07:43:46.000Z</published>
    <updated>2018-09-05T08:09:08.091Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fuxm9e8785j30je09aaau.jpg" alt=""></p><center><strong>类加载过程、类加载器、双亲委派模型</strong></center><a id="more"></a><h3 id="1-类加载机制"><a href="#1-类加载机制" class="headerlink" title="1. 类加载机制"></a>1. 类加载机制</h3><hr><h4 id="1-1-虚拟机类加载机制的概念"><a href="#1-1-虚拟机类加载机制的概念" class="headerlink" title="1.1 虚拟机类加载机制的概念"></a>1.1 虚拟机类加载机制的概念</h4><p>虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化。最终形成可以被虚拟机最直接使用的java类型的过程就是虚拟机的类加载机制。</p><h4 id="1-2-Java语言的动态加载和动态连接"><a href="#1-2-Java语言的动态加载和动态连接" class="headerlink" title="1.2 Java语言的动态加载和动态连接"></a>1.2 Java语言的动态加载和动态连接</h4><p>Java语言中类型的加载连接以及初始化过程都是在程序运行期间完成的，提高了java应用的灵活性。</p><h3 id="2-类加载的时机"><a href="#2-类加载的时机" class="headerlink" title="2. 类加载的时机"></a>2. 类加载的时机</h3><hr><p><strong>虚拟机严格规定了五种情况必须对类立即进行“初始化”:</strong></p><ul><li>使用new关键字实例化对象的时候，读取或设置一个类的静态字段的时候，已经调用一个类的静态方法的时候。</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化，则需要先出发初始化。</li><li>当初始化一个类的时候，如果发现他的父类没有初始化就会先初始化他的父类。</li><li>当虚拟机启动的时候，用户需要指定一个执行的主类（main()方法所在的类），虚拟机会先初始化这个类。</li><li>使用JDK1.7动态语言支持的时候的一些情况</li></ul><h3 id="3-类加载过程"><a href="#3-类加载过程" class="headerlink" title="3. 类加载过程"></a>3. 类加载过程</h3><hr><p>类加载过程有五个阶段，分别是：<strong>加载、验证、准备、解析、初始化</strong></p><h4 id="3-1-加载"><a href="#3-1-加载" class="headerlink" title="3.1 加载"></a>3.1 加载</h4><p><strong>加载过程基本由三个基本动作组成：</strong></p><ul><li>通过类型的完全限定名，产生一个代表该类型的二进制数据流(zip包中获取、网络中获取如applet，运行时计算生成例如动态代理技术，由其他文件生成例如JSP)</li><li>解析这个二进制数据流为方法区内的运行时的数据结构</li><li>创建一个表示该类型的java.lang.Class类的实例，作为方法区这个类的各种数据的访问入口</li></ul><blockquote><p>非数组类加载阶段既可以使用系统提供的类加载器来完成，也可以由用户自定义的类加载器去完成。（即重写一个类加载器的loadClass（）方法）</p></blockquote><h4 id="3-2-验证"><a href="#3-2-验证" class="headerlink" title="3.2 验证"></a>3.2 验证</h4><p><strong>为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</strong></p><p>验证分为四个阶段的校验：<strong>文件格式，元数据，字节码，符号引用</strong></p><p><strong>文件格式验证：</strong></p><p>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。这个阶段验证是基于二进制字节流进行的，只有通过这个阶段的验证后，字节流才会进入内存的方法区进行存储，所以后面的3个阶段的全部是基于方法区的存储结构进行的，不会再直接操作字节流。</p><p><strong>元数据验证：</strong></p><p>该阶段对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，目的是保证不存在不符合Java语言规范的元数据信息。</p><p><strong>字节码验证：</strong></p><p>该阶段主要工作时进行数据流和控制流分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为(<em>并非经过验证就绝对安全</em>)。 例如，保证跳转指令不会跳转到方法体以外的字节码指令上、保证方法体中的类型转换是有效的等等。</p><p><strong>符号引用验证：</strong></p><p>校验发生在虚拟机将符号引用转化为直接引用的时候，在解析阶段中发生，为确保解析动作可以正常执行。</p><p>验证的内容：</p><ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类；</li><li>在指定类中是否存在符号方法的字段描述及简单名称所描述的方法和字段；</li><li>符号引用中的类、字段和方法的访问性（private、protected、public、default）是否可被当前类访问。</li></ul><h4 id="3-3-准备"><a href="#3-3-准备" class="headerlink" title="3.3 准备"></a>3.3 准备</h4><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都在方法区中进行分配</strong>(<em>注：此时进行内存分配的只是类变量，也就是被static修饰的变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在java堆中</em>)。</p><p><strong>初始值通常为数据类型的零值，例如：</strong></p><p><code>public static int value = 123;</code></p><p>在准备阶段之后的初始值为int的零值，也就是0，而不是123；</p><blockquote><p>这里需要注意的是boolean的初始值为false</p></blockquote><h4 id="3-4-解析"><a href="#3-4-解析" class="headerlink" title="3.4 解析"></a>3.4 解析</h4><p><strong>解析阶段就是虚拟机将常量池内的符号引用替换为直接引用的过程。</strong></p><p><strong>符号引用(Symbolic References)</strong>： 符号引用以一组符号来描述所引用的目标，符号可以是符合约定的任何形式的字面量，符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。</p><p><strong>直接引用（Direct References）:</strong> 直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用与虚拟机实现的内存布局相关，引用的目标必定已经在内存中存在。</p><p><strong>需要注意的是：</strong></p><ul><li>虚拟机规范没有规定解析阶段发生的具体时间，虚拟机实现可以根据需要来判断到底是在类被加载时解析还是等到一个符号引用将要被使用前才去解析。</li><li>虚拟机可以实现对第一次解析结果进行缓存，避免解析动作的重复进行</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行</li></ul><h4 id="3-5-初始化"><a href="#3-5-初始化" class="headerlink" title="3.5 初始化"></a>3.5 初始化</h4><p>类初始化阶段是类加载的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的java程序代码（或者说是字节码）。</p><h3 id="4-类加载器"><a href="#4-类加载器" class="headerlink" title="4. 类加载器"></a>4. 类加载器</h3><hr><h4 id="4-1-类与类加载器"><a href="#4-1-类与类加载器" class="headerlink" title="4.1 类与类加载器"></a>4.1 类与类加载器</h4><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。如果两个类来源于同一个Class文件，只要加载它们的类加载器不同，那么这两个类就必定不相等。</p><h4 id="4-2-类加载器"><a href="#4-2-类加载器" class="headerlink" title="4.2 类加载器"></a>4.2 类加载器</h4><p>对于java开发人员来讲，最常用的为下面三种系统提供的类加载器：</p><p><strong>启动类加载器（Bootstrap ClassLoader）：</strong></p><p>这个类加载器负责将存放在\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。</p><p><strong>扩展类加载器（Extension ClassLoader）：</strong></p><p>这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</p><p><strong>应用程序类加载器（Application ClassLoader）：</strong></p><p>这个类加载器由sun.misc.Launcher$AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p><strong>双亲委派模型（Pattern Delegation Model）</strong>,要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器。这里父子关系通常是子类通过组合关系而不是继承关系来复用父加载器的代码。</p><center><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fuxm25hmiej30ip09iaes.jpg" alt="双亲委派模型"></center><p><strong>双亲委派模型的工作过程：</strong></p><p>如果一个类加载器收到了类加载的请求，先把这个请求委派给父类加载器去完成（所以所有的加载请求最终都应该传送到顶层的启动类加载器中），只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己去加载。</p><p><strong>双亲委派模型的意义：</strong></p><p>比如两个类A和类B都要加载System类：</p><ul><li>如果不用委托而是自己加载自己的，那么类A就会加载一份System字节码，然后类B又会加载一份System字节码，这样内存中就出现了两份System字节码。</li><li>如果使用委托机制，会递归的向父类查找，也就是首选用Bootstrap尝试加载，如果找不到再向下。这里的System就能在Bootstrap中找到然后加载，如果此时类B也要加载System，也从Bootstrap开始，此时Bootstrap发现已经加载过了System那么直接返回内存中的System即可而不需要重新加载，这样内存中就只有一份System的字节码了。</li><li>java类随着它的类加载器一起具备了一种带有优先级的层次关系。</li></ul><hr><p>本文参考：</p><ul><li>《深入理解JAVA虚拟机》第二版</li><li><a href="https://github.com/Snailclimb/Java-Guide" target="_blank" rel="noopener">https://github.com/Snailclimb/Java-Guide</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0068YiZcgy1fuxm9e8785j30je09aaau.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;类加载过程、类加载器、双亲委派模型&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>几种常见的排序算法</title>
    <link href="http://yoursite.com/2018/08/12/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/08/12/几种常见的排序算法/</id>
    <published>2018-08-12T09:14:46.000Z</published>
    <updated>2018-09-20T16:11:21.846Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fu71g2x4utj30rs0jnqbw.jpg" alt=""><br><a id="more"></a></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="快排算法思想"><a href="#快排算法思想" class="headerlink" title="快排算法思想"></a>快排算法思想</h3><p>1．先从数列中取出一个数作为基准数。</p><p>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</p><p>3．再对左右区间重复第二步，直到各区间只有一个数。</p><h3 id="代码总结"><a href="#代码总结" class="headerlink" title="代码总结"></a>代码总结</h3><p>1．i =L; j = R; 将基准数挖出形成第一个坑a[i]。</p><p>2．j–由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。</p><p>3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。</p><p>4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中。</p><h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       int[] arr = &#123;4,5,7,8,1,2,3,6&#125;;</span><br><span class="line">       quick_sort(arr, 0, arr.length - 1);</span><br><span class="line">       System.out.println(&quot;排序结果：&quot; + Arrays.toString(arr));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void quick_sort(int s[], int left, int right)</span><br><span class="line">   &#123;</span><br><span class="line">       if (left &lt; right)</span><br><span class="line">       &#123;</span><br><span class="line">           //Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注</span><br><span class="line">           int i = left, j = right, x = s[left];</span><br><span class="line">           while (i &lt; j)</span><br><span class="line">           &#123;</span><br><span class="line">               while(i &lt; j &amp;&amp; s[j] &gt;= x) // 从右向左找第一个小于x的数</span><br><span class="line">                   j--;</span><br><span class="line">               if(i &lt; j)</span><br><span class="line">                   s[i++] = s[j];</span><br><span class="line"></span><br><span class="line">               while(i &lt; j &amp;&amp; s[i] &lt; x) // 从左向右找第一个大于等于x的数</span><br><span class="line">                   i++;</span><br><span class="line">               if(i &lt; j)</span><br><span class="line">                   s[j--] = s[i];</span><br><span class="line">           &#125;</span><br><span class="line">           s[i] = x;</span><br><span class="line">           quick_sort(s, left, i - 1); // 递归调用</span><br><span class="line">           quick_sort(s, i + 1, right);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：时间复杂度为O(N*logN);快排算法中的枢纽值可以是第一个最后一个或者数组中间的值，个人来讲比较喜欢第一个数当作枢纽==</p></blockquote><hr><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="冒泡算法思想"><a href="#冒泡算法思想" class="headerlink" title="冒泡算法思想"></a>冒泡算法思想</h3><p>1．比较相邻的前后二个数据，如果前面数据大于后面的数据，就将二个数据交换。</p><p>2．这样对数组的第0个数据到N-1个数据进行一次遍历后，最大的一个数据就“沉”到数组第N-1个位置。</p><p>3．N=N-1，如果N不为0就重复前面二步，否则排序完成。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void BubbleSort(int[] arr)&#123;</span><br><span class="line">        int n = arr.length;</span><br><span class="line">        int i,j;</span><br><span class="line">        for (i=0;i&lt;n;i++)&#123;</span><br><span class="line">            for (j=1;j&lt;n-i;j++)&#123;</span><br><span class="line">                if (arr[j] &lt; arr[j-1])&#123;</span><br><span class="line">                    int temp =0;</span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j-1];</span><br><span class="line">                    arr[j-1] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>冒泡排序毕竟是一种效率低下的排序方法，在数据规模很小时，可以采用。数据规模比较大时，最好用其它排序方法。</p></blockquote><hr><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>直接插入排序(Insertion Sort)的基本思想是：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入完成为止。</p><h3 id="代码总结-1"><a href="#代码总结-1" class="headerlink" title="代码总结"></a>代码总结</h3><p>设数组为a[0…n-1]，n为arr.length。</p><ol><li><p>初始时，a[0]自成1个有序区，无序区为a[1..n-1]。令i=1</p></li><li><p>将a[i]并入当前的有序区a[0…i-1]中形成a[0…i]的有序区间。</p></li><li><p>i++并重复第二步直到i==n-1。排序完成。</p></li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void insertSort(int[] arr)&#123;</span><br><span class="line">        int n = arr.length;</span><br><span class="line">        int i,j;</span><br><span class="line">        for (i = 1; i &lt; n;i++)&#123;</span><br><span class="line">            for (j=i-1; j&gt;=0 &amp;&amp; arr[j] &gt; arr[j+1]; j--)&#123;</span><br><span class="line">                swap(arr,j,j+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>直接选择排序和直接插入排序类似，都将数据分为有序区和无序区，所不同的是直接插入排序是将无序区的第一个元素直接插入到有序区以形成一个更大的有序区，而直接选择排序是从无序区选一个最小的元素直接放到有序区的最后。</p><h3 id="代码总结-2"><a href="#代码总结-2" class="headerlink" title="代码总结"></a>代码总结</h3><p>设数组为a[0…n-1]。</p><ol><li><p>初始时，数组全为无序区为a[0..n-1]。令i=0</p></li><li><p>在无序区a[i…n-1]中选取一个最小的元素，将其与a[i]交换。交换之后a[0…i]就形成了一个有序区。</p></li><li><p>i++并重复第二步直到i==n-1。排序完成。</p></li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void Selectsort(int[] arr)</span><br><span class="line">&#123;</span><br><span class="line">    int n=arr.length;</span><br><span class="line">    int i, j, nMinIndex;</span><br><span class="line">    for (i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nMinIndex = i; //找最小元素的位置</span><br><span class="line">        for (j = i + 1; j &lt; n; j++)</span><br><span class="line">            if (a[j] &lt; a[nMinIndex])</span><br><span class="line">                nMinIndex = j;</span><br><span class="line"> </span><br><span class="line">        Swap(a[i], a[nMinIndex]); //将这个元素放到无序区的开头</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="关于swap的使用"><a href="#关于swap的使用" class="headerlink" title="关于swap的使用"></a>关于swap的使用</h2><h3 id="如何不使用中间数来进行数组中数字交换？"><a href="#如何不使用中间数来进行数组中数字交换？" class="headerlink" title="如何不使用中间数来进行数组中数字交换？"></a>如何不使用中间数来进行数组中数字交换？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void Swap1(int[] arr,int a, int b) &#123;</span><br><span class="line">        if (arr[a] != arr[b]) &#123;</span><br><span class="line">            arr[a] ^= arr[b];</span><br><span class="line">            arr[b] ^= arr[a];</span><br><span class="line">            arr[a] ^= arr[b];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>数组为引用类型，对数组进行修改，原数组的内容也会被修改，所以这里调用方法之后数组两个数据会被调换;如果传入int类型，为基本数据类型，只是传入数字到方法中，对main函数中的a,b并没有影响，不会被改变</p></blockquote><hr><p>参考链接<a href="https://blog.csdn.net/MoreWindows/article/details/17488865" target="_blank" rel="noopener">https://blog.csdn.net/MoreWindows/article/details/17488865</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0068YiZcgy1fu71g2x4utj30rs0jnqbw.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>几种常见的排序算法</title>
    <link href="http://yoursite.com/2018/08/12/Java%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/08/12/Java面试-算法/</id>
    <published>2018-08-12T09:14:46.000Z</published>
    <updated>2018-09-20T16:06:00.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a><center>排序算法</center></h2><p><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fu71g2x4utj30rs0jnqbw.jpg" alt=""><br><a id="more"></a></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="快排算法思想"><a href="#快排算法思想" class="headerlink" title="快排算法思想"></a>快排算法思想</h3><p>1．先从数列中取出一个数作为基准数。</p><p>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</p><p>3．再对左右区间重复第二步，直到各区间只有一个数。</p><h3 id="代码总结"><a href="#代码总结" class="headerlink" title="代码总结"></a>代码总结</h3><p>1．i =L; j = R; 将基准数挖出形成第一个坑a[i]。</p><p>2．j–由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。</p><p>3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。</p><p>4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中。</p><h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       int[] arr = &#123;4,5,7,8,1,2,3,6&#125;;</span><br><span class="line">       quick_sort(arr, 0, arr.length - 1);</span><br><span class="line">       System.out.println(&quot;排序结果：&quot; + Arrays.toString(arr));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void quick_sort(int s[], int left, int right)</span><br><span class="line">   &#123;</span><br><span class="line">       if (left &lt; right)</span><br><span class="line">       &#123;</span><br><span class="line">           //Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注</span><br><span class="line">           int i = left, j = right, x = s[left];</span><br><span class="line">           while (i &lt; j)</span><br><span class="line">           &#123;</span><br><span class="line">               while(i &lt; j &amp;&amp; s[j] &gt;= x) // 从右向左找第一个小于x的数</span><br><span class="line">                   j--;</span><br><span class="line">               if(i &lt; j)</span><br><span class="line">                   s[i++] = s[j];</span><br><span class="line"></span><br><span class="line">               while(i &lt; j &amp;&amp; s[i] &lt; x) // 从左向右找第一个大于等于x的数</span><br><span class="line">                   i++;</span><br><span class="line">               if(i &lt; j)</span><br><span class="line">                   s[j--] = s[i];</span><br><span class="line">           &#125;</span><br><span class="line">           s[i] = x;</span><br><span class="line">           quick_sort(s, left, i - 1); // 递归调用</span><br><span class="line">           quick_sort(s, i + 1, right);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：时间复杂度为O(N*logN);快排算法中的枢纽值可以是第一个最后一个或者数组中间的值，个人来讲比较喜欢第一个数当作枢纽==</p></blockquote><hr><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="冒泡算法思想"><a href="#冒泡算法思想" class="headerlink" title="冒泡算法思想"></a>冒泡算法思想</h3><p>1．比较相邻的前后二个数据，如果前面数据大于后面的数据，就将二个数据交换。</p><p>2．这样对数组的第0个数据到N-1个数据进行一次遍历后，最大的一个数据就“沉”到数组第N-1个位置。</p><p>3．N=N-1，如果N不为0就重复前面二步，否则排序完成。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void BubbleSort(int[] arr)&#123;</span><br><span class="line">        int n = arr.length;</span><br><span class="line">        int i,j;</span><br><span class="line">        for (i=0;i&lt;n;i++)&#123;</span><br><span class="line">            for (j=1;j&lt;n-i;j++)&#123;</span><br><span class="line">                if (arr[j] &lt; arr[j-1])&#123;</span><br><span class="line">                    int temp =0;</span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j-1];</span><br><span class="line">                    arr[j-1] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>冒泡排序毕竟是一种效率低下的排序方法，在数据规模很小时，可以采用。数据规模比较大时，最好用其它排序方法。</p></blockquote><hr><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>直接插入排序(Insertion Sort)的基本思想是：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入完成为止。</p><h3 id="代码总结-1"><a href="#代码总结-1" class="headerlink" title="代码总结"></a>代码总结</h3><p>设数组为a[0…n-1]，n为arr.length。</p><ol><li><p>初始时，a[0]自成1个有序区，无序区为a[1..n-1]。令i=1</p></li><li><p>将a[i]并入当前的有序区a[0…i-1]中形成a[0…i]的有序区间。</p></li><li><p>i++并重复第二步直到i==n-1。排序完成。</p></li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void insertSort(int[] arr)&#123;</span><br><span class="line">        int n = arr.length;</span><br><span class="line">        int i,j;</span><br><span class="line">        for (i = 1; i &lt; n;i++)&#123;</span><br><span class="line">            for (j=i-1; j&gt;=0 &amp;&amp; arr[j] &gt; arr[j+1]; j--)&#123;</span><br><span class="line">                swap(arr,j,j+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>直接选择排序和直接插入排序类似，都将数据分为有序区和无序区，所不同的是直接插入排序是将无序区的第一个元素直接插入到有序区以形成一个更大的有序区，而直接选择排序是从无序区选一个最小的元素直接放到有序区的最后。</p><h3 id="代码总结-2"><a href="#代码总结-2" class="headerlink" title="代码总结"></a>代码总结</h3><p>设数组为a[0…n-1]。</p><ol><li><p>初始时，数组全为无序区为a[0..n-1]。令i=0</p></li><li><p>在无序区a[i…n-1]中选取一个最小的元素，将其与a[i]交换。交换之后a[0…i]就形成了一个有序区。</p></li><li><p>i++并重复第二步直到i==n-1。排序完成。</p></li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void Selectsort(int[] arr)</span><br><span class="line">&#123;</span><br><span class="line">    int n=arr.length;</span><br><span class="line">    int i, j, nMinIndex;</span><br><span class="line">    for (i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nMinIndex = i; //找最小元素的位置</span><br><span class="line">        for (j = i + 1; j &lt; n; j++)</span><br><span class="line">            if (a[j] &lt; a[nMinIndex])</span><br><span class="line">                nMinIndex = j;</span><br><span class="line"> </span><br><span class="line">        Swap(a[i], a[nMinIndex]); //将这个元素放到无序区的开头</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="关于swap的使用"><a href="#关于swap的使用" class="headerlink" title="关于swap的使用"></a>关于swap的使用</h2><h3 id="如何不使用中间数来进行数组中数字交换？"><a href="#如何不使用中间数来进行数组中数字交换？" class="headerlink" title="如何不使用中间数来进行数组中数字交换？"></a>如何不使用中间数来进行数组中数字交换？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void Swap1(int[] arr,int a, int b) &#123;</span><br><span class="line">        if (arr[a] != arr[b]) &#123;</span><br><span class="line">            arr[a] ^= arr[b];</span><br><span class="line">            arr[b] ^= arr[a];</span><br><span class="line">            arr[a] ^= arr[b];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>数组为引用类型，对数组进行修改，原数组的内容也会被修改，所以这里调用方法之后数组两个数据会被调换;如果传入int类型，为基本数据类型，只是传入数字到方法中，对main函数中的a,b并没有影响，不会被改变</p></blockquote><hr><p>参考链接<a href="https://blog.csdn.net/MoreWindows/article/details/17488865" target="_blank" rel="noopener">https://blog.csdn.net/MoreWindows/article/details/17488865</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;&lt;center&gt;排序算法&lt;/center&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0068YiZcgy1fu71g2x4utj30rs0jnqbw.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>面试回顾（一）</title>
    <link href="http://yoursite.com/2018/08/10/Java%E9%9D%A2%E8%AF%95-%E4%B8%80/"/>
    <id>http://yoursite.com/2018/08/10/Java面试-一/</id>
    <published>2018-08-10T04:34:35.000Z</published>
    <updated>2018-09-20T16:13:35.670Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fu4ie0t80jj30xc0i5k60.jpg" alt=""><br><a id="more"></a></p><h4 id="1-Java中的值传递和引用传递："><a href="#1-Java中的值传递和引用传递：" class="headerlink" title="1. Java中的值传递和引用传递："></a>1. Java中的值传递和引用传递：</h4><hr><p>对象传递（数组、类、接口）是引用传递，原始类型数据（整型、浮点型、字符型、布尔型）传递是值传递。</p><p><strong>值传递</strong>是指对象被值传递，意味着传递了对象的一个副本，即使副本被改变，也不会影响源对象。（因为值传递的时候，实际上是将实参的值复制一份给形参。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int num1 = 10;</span><br><span class="line">    int num2 = 20;</span><br><span class="line"></span><br><span class="line">    swap(num1, num2);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;num1 = &quot; + num1);</span><br><span class="line">    System.out.println(&quot;num2 = &quot; + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void swap(int a, int b) &#123;</span><br><span class="line">    int temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;a = &quot; + a);</span><br><span class="line">    System.out.println(&quot;b = &quot; + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 20</span><br><span class="line">b = 10</span><br><span class="line">num1 = 10</span><br><span class="line">num2 = 20</span><br></pre></td></tr></table></figure></p><p><strong>引用传递</strong>是指对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象的改变会反映到所有的对象上。（因为引用传递的时候，实际上是将实参的地址值复制一份给形参。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int[] arr = &#123;1,2,3,4,5&#125;;</span><br><span class="line"></span><br><span class="line">    change(arr);</span><br><span class="line"></span><br><span class="line">    System.out.println(arr[0]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void change(int[] array) &#123;</span><br><span class="line">    //将数组的第一个元素变为0</span><br><span class="line">    array[0] = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><h4 id="2-与equals"><a href="#2-与equals" class="headerlink" title="2. ==与equals"></a>2. ==与equals</h4><hr><p>== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。</p><p>equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><p>情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。<br>情况2：类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class test1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String a = new String(&quot;ab&quot;); // a 为一个引用</span><br><span class="line">        String b = new String(&quot;ab&quot;); // b为另一个引用,对象的内容一样</span><br><span class="line">        String aa = &quot;ab&quot;; // 放在常量池中</span><br><span class="line">        String bb = &quot;ab&quot;; // 从常量池中查找</span><br><span class="line">        if (aa == bb) // true</span><br><span class="line">            System.out.println(&quot;aa==bb&quot;);</span><br><span class="line">        if (a == b) // false，非同一对象</span><br><span class="line">            System.out.println(&quot;a==b&quot;);</span><br><span class="line">        if (a.equals(b)) // true</span><br><span class="line">            System.out.println(&quot;aEQb&quot;);</span><br><span class="line">        if (42 == 42.0) &#123; // true</span><br><span class="line">            System.out.println(&quot;true&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><ul><li>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。</li><li>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</li></ul><h4 id="3-hashCode与equals"><a href="#3-hashCode与equals" class="headerlink" title="3. hashCode与equals"></a>3. hashCode与equals</h4><hr><ul><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个对象分别调用equals方法都返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li>因此，equals方法被覆盖过，则hashCode方法也必须被覆盖</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ul><h4 id="4-面向对象和面向过程的区别"><a href="#4-面向对象和面向过程的区别" class="headerlink" title="4. 面向对象和面向过程的区别"></a>4. 面向对象和面向过程的区别</h4><hr><h5 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h5><ul><li>优点：性能高，因为类调用时需要实例化，开销比较大，比较消耗资源；比如嵌入式开发，Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</li><li>缺点：没有面向对象易维护，易复用，易扩展。<h5 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h5></li><li>优点：易维护，易复用，易扩展，由于面向对象有封装，继承，多态的特性，可以设计出低耦合的系统，使系统更加的灵活，易于维护。</li><li>性格比面向过程低。</li></ul><h4 id="5-Java代码运行过程"><a href="#5-Java代码运行过程" class="headerlink" title="5.Java代码运行过程"></a>5.Java代码运行过程</h4><hr><p>Java源代码—-&gt;编译器—-&gt;jvm可执行的Java字节码(即.class文件中的虚拟指令)—-&gt;jvm—-&gt;jvm中的解释器—-&gt;机器可执行的二进制机器码—-&gt;程序运行</p><h5 id="采用字节码的好处"><a href="#采用字节码的好处" class="headerlink" title="采用字节码的好处"></a>采用字节码的好处</h5><p>一定程度上解决了传统解释性语言执行效率低的问题，同时又保持了解释性语言可移植的特点。在运行java程序时比较高效。而且因为字节码并不专对一种特定的机器，因此java程序无需重新编译便可在多种不同的计算机上运行。</p><h4 id="6-java与c-的区别"><a href="#6-java与c-的区别" class="headerlink" title="6. java与c++的区别"></a>6. java与c++的区别</h4><hr><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java不提供指针来直接访问内存，程序内存更加安全</li><li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。</li><li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li></ul><h4 id="7-重载和重写的区别"><a href="#7-重载和重写的区别" class="headerlink" title="7. 重载和重写的区别"></a>7. 重载和重写的区别</h4><hr><p><strong>重载</strong></p><p>同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　</p><p><strong>重写</strong></p><p>发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private则子类就不能重写该方法。</p><h4 id="8-Java面向对象编程的三大特性：封装，继承，多态"><a href="#8-Java面向对象编程的三大特性：封装，继承，多态" class="headerlink" title="8. Java面向对象编程的三大特性：封装，继承，多态"></a>8. Java面向对象编程的三大特性：封装，继承，多态</h4><hr><p><strong>封装</strong></p><p>封装是将一个对象的属性私有化，同时提供一些给外界访问的属性的方法(private, getter and setter)</p><p><strong>继承</strong></p><p>继承是将已经存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以使用父类的功能，但不能选择性的继承父类。</p><p><strong>关于继承的三点</strong></p><ol><li>子类拥有父类非private的属性和方法(父类的构造方法同样不能被继承)</li><li>子类可以拥有自己的属性和方法</li><li>子类可以用自己的方法实现父类的方法(重写)</li></ol><p><strong>多态</strong></p><p>多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p>java中有两种形式可以实现多态：继承(多个子类对同一方法的重写)和接口(实现接口并覆盖接口中的同一方法).</p><h4 id="9-String、StringBuffer和StringBuilder的却别是什么？String为什么是不可变的"><a href="#9-String、StringBuffer和StringBuilder的却别是什么？String为什么是不可变的" class="headerlink" title="9. String、StringBuffer和StringBuilder的却别是什么？String为什么是不可变的"></a>9. String、StringBuffer和StringBuilder的却别是什么？String为什么是不可变的</h4><hr><p><strong>可变性</strong></p><p>String类中使用字符数组来保存字符串，private、final、char、value[]，所以String对象是不变的。StringBuffer和StringBuilder都继承自AbstractStringBuilder类，在这个类中也是使用字符数组保存字符串，char、value[]，所以这两种对象是可变的。</p><p><strong>线程安全性</strong></p><ul><li>String中对象是不变的，线程安全</li><li>StringBuffer对方法加了同步锁或者对调用方法添加了同步锁，线程安全</li><li>StringBuilder并没有对方法添加同步锁，所以非线程安全</li></ul><p><strong>性能</strong></p><p>由于对String修改的时候都会生成一个新的String对象，然后将指针指向新的String对象；StringBuffer每次都会对对象本身进行操作，而不是生成新的对象。相同情况下StringBuilder要比StringBuffer性能提高10%~15%左右，但是线程不安全</p><p><strong>使用情况</strong></p><ul><li>String：操作少量的数据用</li><li>StringBuffer: 多线程操作字符串缓冲区下大量数据</li><li>StringBuilder：单线程下操作字符串缓冲区中大量数据</li></ul><h4 id="10-Java中空参构造方法的作用？"><a href="#10-Java中空参构造方法的作用？" class="headerlink" title="10. Java中空参构造方法的作用？"></a>10. Java中空参构造方法的作用？</h4><hr><p>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p><blockquote><p>在java的子类中，不会继承父类的构造函数，但是在子类实例化的时候会调用父类的构造函数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        A ab=new B();  //执行到此处,结果: 1a2b</span><br><span class="line">        ab=new B();//执行到此处,结果: 1a2b2b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class A&#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.print(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public A() &#123;</span><br><span class="line">        System.out.print(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class B extends A&#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.print(&quot;a&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public B() &#123;</span><br><span class="line">        System.out.print(&quot;b&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-接口和抽象类的区别"><a href="#11-接口和抽象类的区别" class="headerlink" title="11. 接口和抽象类的区别"></a>11. 接口和抽象类的区别</h4><hr><ul><li>接口的方法默认是public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法</li><li>接口中的实例变量默认是final类型的，而抽象类中则不一定</li><li>一个类可以实现多个接口，但最多只能实现一个抽象类</li><li>一个类实现接口的话要实现接口的所有方法，而抽象类不一定</li><li>接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象；从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</li></ul><h4 id="12-成员变量与局部变量的区别有那些？"><a href="#12-成员变量与局部变量的区别有那些？" class="headerlink" title="12.  成员变量与局部变量的区别有那些？"></a>12.  成员变量与局部变量的区别有那些？</h4><hr><ul><li>从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；但是，成员变量和局部变量都能被final所修饰；</li><li>从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存</li><li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li><li>成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被final修饰但没有被static修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。</li></ul><h4 id="13-简述线程，程序、进程的基本概念。以及他们之间关系是什么？"><a href="#13-简述线程，程序、进程的基本概念。以及他们之间关系是什么？" class="headerlink" title="13. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？"></a>13. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？</h4><hr><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p><p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。++线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定++，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p><h4 id="14-线程有哪些基本状态？这些状态是如何定义的"><a href="#14-线程有哪些基本状态？这些状态是如何定义的" class="headerlink" title="14. 线程有哪些基本状态？这些状态是如何定义的"></a>14. 线程有哪些基本状态？这些状态是如何定义的</h4><hr><ol><li>新建(new)：新创建了一个线程对象。</li><li>可运行(runnable)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。</li><li>运行(running)：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。</li><li>阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种： (一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waitting queue)中。 (二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。 (三). 其他阻塞: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</li><li>死亡(dead)：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。<br><img src="https://camo.githubusercontent.com/5b764ff5af6204f82c7ae6237b20c41f9505aef8/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f382f392f313635316631396437633465393361333f773d38373626683d34393226663d706e6726733d313238303932" alt="image"></li></ol><h4 id="15-sleep-方法和wait-方法简单对比"><a href="#15-sleep-方法和wait-方法简单对比" class="headerlink" title="15. sleep()方法和wait()方法简单对比"></a>15. sleep()方法和wait()方法简单对比</h4><hr><ul><li>两者最主要的区别在于：sleep方法没有释放锁，而wait方法释放了锁 。</li><li>两者都可以暂停线程的执行。</li><li>Wait通常被用于线程间交互/通信，sleep通常被用于暂停执行。</li><li>wait()方法是Object类中的方法，被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者nofifyAl()方法。sleep()方法是线程类的方法，执行完成后，线程会自动苏醒。</li></ul><h4 id="16-为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？"><a href="#16-为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？" class="headerlink" title="16. 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？"></a>16. 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</h4><hr><p>new一个Thread，线程进入了新建状态;调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。  start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。 而直接执行run()方法，会把run方法当成一个mian线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p><strong>总结： 调用start方法方可启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法调用，还是在主线程里执行。</strong></p><h4 id="17-什么是线程安全？"><a href="#17-什么是线程安全？" class="headerlink" title="17. 什么是线程安全？"></a>17. 什么是线程安全？</h4><hr><p>当多个线程访问某个方法时，不管你通过怎样的调用方式或者说这些线程如何交替的执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类时线程安全的。</p><hr><p>面试问题基本都在链接中，我只不过手打了一遍增强记忆，如有侵权，私信我删QAQ</p><p>参考链接<a href="https://github.com/Snailclimb/Java-Guide" target="_blank" rel="noopener">https://github.com/Snailclimb/Java-Guide</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0068YiZcgy1fu4ie0t80jj30xc0i5k60.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="java，面试" scheme="http://yoursite.com/tags/java%EF%BC%8C%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java面试(一)</title>
    <link href="http://yoursite.com/2018/08/10/%E9%9D%A2%E8%AF%95%E5%9B%9E%E9%A1%BE%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/08/10/面试回顾（一）/</id>
    <published>2018-08-10T04:34:35.000Z</published>
    <updated>2018-09-03T02:23:12.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java基础面试问题总结"><a href="#java基础面试问题总结" class="headerlink" title="java基础面试问题总结"></a><center>java基础面试问题总结</center></h1><p><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fu4ie0t80jj30xc0i5k60.jpg" alt=""><br><a id="more"></a></p><h4 id="1-Java中的值传递和引用传递："><a href="#1-Java中的值传递和引用传递：" class="headerlink" title="1. Java中的值传递和引用传递："></a>1. Java中的值传递和引用传递：</h4><hr><p>对象传递（数组、类、接口）是引用传递，原始类型数据（整型、浮点型、字符型、布尔型）传递是值传递。</p><p><strong>值传递</strong>是指对象被值传递，意味着传递了对象的一个副本，即使副本被改变，也不会影响源对象。（因为值传递的时候，实际上是将实参的值复制一份给形参。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int num1 = 10;</span><br><span class="line">    int num2 = 20;</span><br><span class="line"></span><br><span class="line">    swap(num1, num2);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;num1 = &quot; + num1);</span><br><span class="line">    System.out.println(&quot;num2 = &quot; + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void swap(int a, int b) &#123;</span><br><span class="line">    int temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;a = &quot; + a);</span><br><span class="line">    System.out.println(&quot;b = &quot; + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 20</span><br><span class="line">b = 10</span><br><span class="line">num1 = 10</span><br><span class="line">num2 = 20</span><br></pre></td></tr></table></figure></p><p><strong>引用传递</strong>是指对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象的改变会反映到所有的对象上。（因为引用传递的时候，实际上是将实参的地址值复制一份给形参。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int[] arr = &#123;1,2,3,4,5&#125;;</span><br><span class="line"></span><br><span class="line">    change(arr);</span><br><span class="line"></span><br><span class="line">    System.out.println(arr[0]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void change(int[] array) &#123;</span><br><span class="line">    //将数组的第一个元素变为0</span><br><span class="line">    array[0] = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><h4 id="2-与equals"><a href="#2-与equals" class="headerlink" title="2. ==与equals"></a>2. ==与equals</h4><hr><p>== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。</p><p>equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><p>情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。<br>情况2：类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class test1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String a = new String(&quot;ab&quot;); // a 为一个引用</span><br><span class="line">        String b = new String(&quot;ab&quot;); // b为另一个引用,对象的内容一样</span><br><span class="line">        String aa = &quot;ab&quot;; // 放在常量池中</span><br><span class="line">        String bb = &quot;ab&quot;; // 从常量池中查找</span><br><span class="line">        if (aa == bb) // true</span><br><span class="line">            System.out.println(&quot;aa==bb&quot;);</span><br><span class="line">        if (a == b) // false，非同一对象</span><br><span class="line">            System.out.println(&quot;a==b&quot;);</span><br><span class="line">        if (a.equals(b)) // true</span><br><span class="line">            System.out.println(&quot;aEQb&quot;);</span><br><span class="line">        if (42 == 42.0) &#123; // true</span><br><span class="line">            System.out.println(&quot;true&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><ul><li>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。</li><li>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</li></ul><h4 id="3-hashCode与equals"><a href="#3-hashCode与equals" class="headerlink" title="3. hashCode与equals"></a>3. hashCode与equals</h4><hr><ul><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个对象分别调用equals方法都返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li>因此，equals方法被覆盖过，则hashCode方法也必须被覆盖</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ul><h4 id="4-面向对象和面向过程的区别"><a href="#4-面向对象和面向过程的区别" class="headerlink" title="4. 面向对象和面向过程的区别"></a>4. 面向对象和面向过程的区别</h4><hr><h5 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h5><ul><li>优点：性能高，因为类调用时需要实例化，开销比较大，比较消耗资源；比如嵌入式开发，Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</li><li>缺点：没有面向对象易维护，易复用，易扩展。<h5 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h5></li><li>优点：易维护，易复用，易扩展，由于面向对象有封装，继承，多态的特性，可以设计出低耦合的系统，使系统更加的灵活，易于维护。</li><li>性格比面向过程低。</li></ul><h4 id="5-Java代码运行过程"><a href="#5-Java代码运行过程" class="headerlink" title="5.Java代码运行过程"></a>5.Java代码运行过程</h4><hr><p>Java源代码—-&gt;编译器—-&gt;jvm可执行的Java字节码(即.class文件中的虚拟指令)—-&gt;jvm—-&gt;jvm中的解释器—-&gt;机器可执行的二进制机器码—-&gt;程序运行</p><h5 id="采用字节码的好处"><a href="#采用字节码的好处" class="headerlink" title="采用字节码的好处"></a>采用字节码的好处</h5><p>一定程度上解决了传统解释性语言执行效率低的问题，同时又保持了解释性语言可移植的特点。在运行java程序时比较高效。而且因为字节码并不专对一种特定的机器，因此java程序无需重新编译便可在多种不同的计算机上运行。</p><h4 id="6-java与c-的区别"><a href="#6-java与c-的区别" class="headerlink" title="6. java与c++的区别"></a>6. java与c++的区别</h4><hr><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java不提供指针来直接访问内存，程序内存更加安全</li><li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。</li><li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li></ul><h4 id="7-重载和重写的区别"><a href="#7-重载和重写的区别" class="headerlink" title="7. 重载和重写的区别"></a>7. 重载和重写的区别</h4><hr><p><strong>重载</strong></p><p>同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　</p><p><strong>重写</strong></p><p>发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private则子类就不能重写该方法。</p><h4 id="8-Java面向对象编程的三大特性：封装，继承，多态"><a href="#8-Java面向对象编程的三大特性：封装，继承，多态" class="headerlink" title="8. Java面向对象编程的三大特性：封装，继承，多态"></a>8. Java面向对象编程的三大特性：封装，继承，多态</h4><hr><p><strong>封装</strong></p><p>封装是将一个对象的属性私有化，同时提供一些给外界访问的属性的方法(private, getter and setter)</p><p><strong>继承</strong></p><p>继承是将已经存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以使用父类的功能，但不能选择性的继承父类。</p><p><strong>关于继承的三点</strong></p><ol><li>子类拥有父类非private的属性和方法(父类的构造方法同样不能被继承)</li><li>子类可以拥有自己的属性和方法</li><li>子类可以用自己的方法实现父类的方法(重写)</li></ol><p><strong>多态</strong></p><p>多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p>java中有两种形式可以实现多态：继承(多个子类对同一方法的重写)和接口(实现接口并覆盖接口中的同一方法).</p><h4 id="9-String、StringBuffer和StringBuilder的却别是什么？String为什么是不可变的"><a href="#9-String、StringBuffer和StringBuilder的却别是什么？String为什么是不可变的" class="headerlink" title="9. String、StringBuffer和StringBuilder的却别是什么？String为什么是不可变的"></a>9. String、StringBuffer和StringBuilder的却别是什么？String为什么是不可变的</h4><hr><p><strong>可变性</strong></p><p>String类中使用字符数组来保存字符串，private、final、char、value[]，所以String对象是不变的。StringBuffer和StringBuilder都继承自AbstractStringBuilder类，在这个类中也是使用字符数组保存字符串，char、value[]，所以这两种对象是可变的。</p><p><strong>线程安全性</strong></p><ul><li>String中对象是不变的，线程安全</li><li>StringBuffer对方法加了同步锁或者对调用方法添加了同步锁，线程安全</li><li>StringBuilder并没有对方法添加同步锁，所以非线程安全</li></ul><p><strong>性能</strong></p><p>由于对String修改的时候都会生成一个新的String对象，然后将指针指向新的String对象；StringBuffer每次都会对对象本身进行操作，而不是生成新的对象。相同情况下StringBuilder要比StringBuffer性能提高10%~15%左右，但是线程不安全</p><p><strong>使用情况</strong></p><ul><li>String：操作少量的数据用</li><li>StringBuffer: 多线程操作字符串缓冲区下大量数据</li><li>StringBuilder：单线程下操作字符串缓冲区中大量数据</li></ul><h4 id="10-Java中空参构造方法的作用？"><a href="#10-Java中空参构造方法的作用？" class="headerlink" title="10. Java中空参构造方法的作用？"></a>10. Java中空参构造方法的作用？</h4><hr><p>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p><blockquote><p>在java的子类中，不会继承父类的构造函数，但是在子类实例化的时候会调用父类的构造函数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        A ab=new B();  //执行到此处,结果: 1a2b</span><br><span class="line">        ab=new B();//执行到此处,结果: 1a2b2b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class A&#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.print(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public A() &#123;</span><br><span class="line">        System.out.print(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class B extends A&#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.print(&quot;a&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public B() &#123;</span><br><span class="line">        System.out.print(&quot;b&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-接口和抽象类的区别"><a href="#11-接口和抽象类的区别" class="headerlink" title="11. 接口和抽象类的区别"></a>11. 接口和抽象类的区别</h4><hr><ul><li>接口的方法默认是public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法</li><li>接口中的实例变量默认是final类型的，而抽象类中则不一定</li><li>一个类可以实现多个接口，但最多只能实现一个抽象类</li><li>一个类实现接口的话要实现接口的所有方法，而抽象类不一定</li><li>接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象；从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</li></ul><h4 id="12-成员变量与局部变量的区别有那些？"><a href="#12-成员变量与局部变量的区别有那些？" class="headerlink" title="12.  成员变量与局部变量的区别有那些？"></a>12.  成员变量与局部变量的区别有那些？</h4><hr><ul><li>从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；但是，成员变量和局部变量都能被final所修饰；</li><li>从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存</li><li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li><li>成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被final修饰但没有被static修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。</li></ul><h4 id="13-简述线程，程序、进程的基本概念。以及他们之间关系是什么？"><a href="#13-简述线程，程序、进程的基本概念。以及他们之间关系是什么？" class="headerlink" title="13. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？"></a>13. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？</h4><hr><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p><p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。++线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定++，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p><h4 id="14-线程有哪些基本状态？这些状态是如何定义的"><a href="#14-线程有哪些基本状态？这些状态是如何定义的" class="headerlink" title="14. 线程有哪些基本状态？这些状态是如何定义的"></a>14. 线程有哪些基本状态？这些状态是如何定义的</h4><hr><ol><li>新建(new)：新创建了一个线程对象。</li><li>可运行(runnable)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。</li><li>运行(running)：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。</li><li>阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种： (一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waitting queue)中。 (二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。 (三). 其他阻塞: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</li><li>死亡(dead)：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。<br><img src="https://camo.githubusercontent.com/5b764ff5af6204f82c7ae6237b20c41f9505aef8/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f382f392f313635316631396437633465393361333f773d38373626683d34393226663d706e6726733d313238303932" alt="image"></li></ol><h4 id="15-sleep-方法和wait-方法简单对比"><a href="#15-sleep-方法和wait-方法简单对比" class="headerlink" title="15. sleep()方法和wait()方法简单对比"></a>15. sleep()方法和wait()方法简单对比</h4><hr><ul><li>两者最主要的区别在于：sleep方法没有释放锁，而wait方法释放了锁 。</li><li>两者都可以暂停线程的执行。</li><li>Wait通常被用于线程间交互/通信，sleep通常被用于暂停执行。</li><li>wait()方法是Object类中的方法，被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者nofifyAl()方法。sleep()方法是线程类的方法，执行完成后，线程会自动苏醒。</li></ul><h4 id="16-为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？"><a href="#16-为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？" class="headerlink" title="16. 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？"></a>16. 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</h4><hr><p>new一个Thread，线程进入了新建状态;调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。  start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。 而直接执行run()方法，会把run方法当成一个mian线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p><strong>总结： 调用start方法方可启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法调用，还是在主线程里执行。</strong></p><h4 id="17-什么是线程安全？"><a href="#17-什么是线程安全？" class="headerlink" title="17. 什么是线程安全？"></a>17. 什么是线程安全？</h4><hr><p>当多个线程访问某个方法时，不管你通过怎样的调用方式或者说这些线程如何交替的执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类时线程安全的。</p><hr><p>面试问题基本都在链接中，我只不过手打了一遍增强记忆，如有侵权，私信我删QAQ</p><p>参考链接<a href="https://github.com/Snailclimb/Java-Guide" target="_blank" rel="noopener">https://github.com/Snailclimb/Java-Guide</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;java基础面试问题总结&quot;&gt;&lt;a href=&quot;#java基础面试问题总结&quot; class=&quot;headerlink&quot; title=&quot;java基础面试问题总结&quot;&gt;&lt;/a&gt;&lt;center&gt;java基础面试问题总结&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0068YiZcgy1fu4ie0t80jj30xc0i5k60.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="java，面试" scheme="http://yoursite.com/tags/java%EF%BC%8C%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>windows使用git遇到HttpRequestException</title>
    <link href="http://yoursite.com/2018/07/23/windows%E4%BD%BF%E7%94%A8git%E9%81%87%E5%88%B0HttpRequestException/"/>
    <id>http://yoursite.com/2018/07/23/windows使用git遇到HttpRequestException/</id>
    <published>2018-07-23T05:01:50.000Z</published>
    <updated>2018-08-13T06:48:31.957Z</updated>
    
    <content type="html"><![CDATA[<p><center>win10使用git进行<code>git push</code>时出现<code>Fatal: HttpRequestException encountered</code>并且需要重新输入用户名和密码的解决方案</center><br><a id="more"></a></p><p>这是因为github<a href="https://githubengineering.com/crypto-removal-notice/" target="_blank" rel="noopener">禁用了弱加密</a>,可以下载<a href="https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/tag/v1.16.2" target="_blank" rel="noopener">最新版本的Git凭据管理器</a>来解决这个问题。<br><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1ftjqev6e56j30sq08s752.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;win10使用git进行&lt;code&gt;git push&lt;/code&gt;时出现&lt;code&gt;Fatal: HttpRequestException encountered&lt;/code&gt;并且需要重新输入用户名和密码的解决方案&lt;/center&gt;&lt;br&gt;
    
    </summary>
    
      <category term="遇到的问题" scheme="http://yoursite.com/categories/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>mongodb无法安装的问题解决</title>
    <link href="http://yoursite.com/2018/06/30/mongodb%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2018/06/30/mongodb无法安装的问题解决/</id>
    <published>2018-06-30T08:10:49.000Z</published>
    <updated>2018-08-13T06:48:13.154Z</updated>
    
    <content type="html"><![CDATA[<p><center>win10安装mongodb遇到mongodb 3.6.5 2008 Setup Wizard ended prematurely问题，无法安装</center><br><a id="more"></a></p><p><img src="https://img-blog.csdn.net/20180619214846303?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjQ0NDk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>解决问题方法：安装的时候取消Compass</p><p><img src="https://img-blog.csdn.net/20180619214953834?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjQ0NDk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>安装成功：<br><img src="https://img-blog.csdn.net/20180619215043676?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjQ0NDk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;win10安装mongodb遇到mongodb 3.6.5 2008 Setup Wizard ended prematurely问题，无法安装&lt;/center&gt;&lt;br&gt;
    
    </summary>
    
      <category term="遇到的问题" scheme="http://yoursite.com/categories/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="mongodb" scheme="http://yoursite.com/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>HelloBlog</title>
    <link href="http://yoursite.com/2018/06/24/HelloBlog/"/>
    <id>http://yoursite.com/2018/06/24/HelloBlog/</id>
    <published>2018-06-24T08:22:35.000Z</published>
    <updated>2018-08-13T08:44:55.840Z</updated>
    
    <content type="html"><![CDATA[<p><center>其实在很久之前大概就像有一个自己的个人博客，大概有多久之前呢，大概是两年前，鬼知道这两年我干了什么＝＝</center><br><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fu85zpkxnwj30rr0el76b.jpg" alt=""><br><a id="more"></a><br>关于博客，采用hexo＋github Pages初步已经搭建完成，也把很多细节和需要修改的东西调整的差不多了，这个博客的搭建大概就结束了，接下来就可以慢慢写自己的博客啦，唯一美中不足的是对于MardDown的语法还不是很熟悉，前路漫漫<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"HelloMyBlog"</span>);</span><br></pre></td></tr></table></figure></p><p align="right">2018-06-24</p><hr><p>今天在写博客，突然就想将next主题完善优化优化，于是就有了眼前的效果</p><ol><li>解决了之前评论冲突的问题，关闭了多说评论，最后在评论的选择上选择了来必力，虽然加载慢了点但是好歹不会被墙</li><li>一直觉得next主题的默认博客界面有些窄，看着不太舒服，就手动修改了页面配置，具体修改方法详见链接<a href="https://blog.csdn.net/csdnSR/article/details/78300820" target="_blank" rel="noopener">https://blog.csdn.net/csdnSR/article/details/78300820</a>,需要注意的是修改完成之后部署之前记得<code>hexo clean</code>，之后<code>hexo g -d</code>直接部署</li><li>给界面背景加上了动态粒子效果<p align="right">2018-8-23</p><br><p align="right">辞树</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;其实在很久之前大概就像有一个自己的个人博客，大概有多久之前呢，大概是两年前，鬼知道这两年我干了什么＝＝&lt;/center&gt;&lt;br&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0068YiZcgy1fu85zpkxnwj30rr0el76b.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="hello" scheme="http://yoursite.com/tags/hello/"/>
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
</feed>
