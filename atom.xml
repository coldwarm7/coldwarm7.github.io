<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>coldwarm7</title>
  
  <subtitle>never stop learning</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-13T06:50:05.727Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>辞树</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java面试-算法</title>
    <link href="http://yoursite.com/2018/08/12/Java%E9%9D%A2%E8%AF%95-%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/08/12/Java面试-算法/</id>
    <published>2018-08-12T09:14:46.000Z</published>
    <updated>2018-08-13T06:50:05.727Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a><center>排序算法</center></h2><p><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fu71g2x4utj30rs0jnqbw.jpg" alt=""><br><a id="more"></a></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="快排算法思想"><a href="#快排算法思想" class="headerlink" title="快排算法思想"></a>快排算法思想</h3><p>1．先从数列中取出一个数作为基准数。</p><p>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</p><p>3．再对左右区间重复第二步，直到各区间只有一个数。</p><h3 id="代码总结"><a href="#代码总结" class="headerlink" title="代码总结"></a>代码总结</h3><p>1．i =L; j = R; 将基准数挖出形成第一个坑a[i]。</p><p>2．j–由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。</p><p>3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。</p><p>4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中。</p><h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       int[] arr = &#123;4,5,7,8,1,2,3,6&#125;;</span><br><span class="line">       quick_sort(arr, 0, arr.length - 1);</span><br><span class="line">       System.out.println(&quot;排序结果：&quot; + Arrays.toString(arr));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void quick_sort(int s[], int left, int right)</span><br><span class="line">   &#123;</span><br><span class="line">       if (left &lt; right)</span><br><span class="line">       &#123;</span><br><span class="line">           //Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注</span><br><span class="line">           int i = left, j = right, x = s[left];</span><br><span class="line">           while (i &lt; j)</span><br><span class="line">           &#123;</span><br><span class="line">               while(i &lt; j &amp;&amp; s[j] &gt;= x) // 从右向左找第一个小于x的数</span><br><span class="line">                   j--;</span><br><span class="line">               if(i &lt; j)</span><br><span class="line">                   s[i++] = s[j];</span><br><span class="line"></span><br><span class="line">               while(i &lt; j &amp;&amp; s[i] &lt; x) // 从左向右找第一个大于等于x的数</span><br><span class="line">                   i++;</span><br><span class="line">               if(i &lt; j)</span><br><span class="line">                   s[j--] = s[i];</span><br><span class="line">           &#125;</span><br><span class="line">           s[i] = x;</span><br><span class="line">           quick_sort(s, left, i - 1); // 递归调用</span><br><span class="line">           quick_sort(s, i + 1, right);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：时间复杂度为O(N*logN);快排算法中的枢纽值可以是第一个最后一个或者数组中间的值，个人来讲比较喜欢第一个数当作枢纽==</p></blockquote><hr><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="冒泡算法思想"><a href="#冒泡算法思想" class="headerlink" title="冒泡算法思想"></a>冒泡算法思想</h3><p>1．比较相邻的前后二个数据，如果前面数据大于后面的数据，就将二个数据交换。</p><p>2．这样对数组的第0个数据到N-1个数据进行一次遍历后，最大的一个数据就“沉”到数组第N-1个位置。</p><p>3．N=N-1，如果N不为0就重复前面二步，否则排序完成。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void BubbleSort(int[] arr)&#123;</span><br><span class="line">        int n = arr.length;</span><br><span class="line">        int i,j;</span><br><span class="line">        for (i=0;i&lt;n;i++)&#123;</span><br><span class="line">            for (j=1;j&lt;n-i;j++)&#123;</span><br><span class="line">                if (arr[j] &lt; arr[j-1])&#123;</span><br><span class="line">                    int temp =0;</span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j-1];</span><br><span class="line">                    arr[j-1] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>冒泡排序毕竟是一种效率低下的排序方法，在数据规模很小时，可以采用。数据规模比较大时，最好用其它排序方法。</p></blockquote><hr><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>直接插入排序(Insertion Sort)的基本思想是：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入完成为止。</p><h3 id="代码总结-1"><a href="#代码总结-1" class="headerlink" title="代码总结"></a>代码总结</h3><p>设数组为a[0…n-1]，n为arr.length。</p><ol><li><p>初始时，a[0]自成1个有序区，无序区为a[1..n-1]。令i=1</p></li><li><p>将a[i]并入当前的有序区a[0…i-1]中形成a[0…i]的有序区间。</p></li><li><p>i++并重复第二步直到i==n-1。排序完成。</p></li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void insertSort(int[] arr)&#123;</span><br><span class="line">        int n = arr.length;</span><br><span class="line">        int i,j;</span><br><span class="line">        for (i = 1; i &lt; n;i++)&#123;</span><br><span class="line">            for (j=i-1; j&gt;=0 &amp;&amp; arr[j] &gt; arr[j+1]; j--)&#123;</span><br><span class="line">                swap(arr,j,j+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>直接选择排序和直接插入排序类似，都将数据分为有序区和无序区，所不同的是直接插入排序是将无序区的第一个元素直接插入到有序区以形成一个更大的有序区，而直接选择排序是从无序区选一个最小的元素直接放到有序区的最后。</p><h3 id="代码总结-2"><a href="#代码总结-2" class="headerlink" title="代码总结"></a>代码总结</h3><p>设数组为a[0…n-1]。</p><ol><li><p>初始时，数组全为无序区为a[0..n-1]。令i=0</p></li><li><p>在无序区a[i…n-1]中选取一个最小的元素，将其与a[i]交换。交换之后a[0…i]就形成了一个有序区。</p></li><li><p>i++并重复第二步直到i==n-1。排序完成。</p></li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void Selectsort(int[] arr)</span><br><span class="line">&#123;</span><br><span class="line">    int n=arr.length;</span><br><span class="line">    int i, j, nMinIndex;</span><br><span class="line">    for (i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nMinIndex = i; //找最小元素的位置</span><br><span class="line">        for (j = i + 1; j &lt; n; j++)</span><br><span class="line">            if (a[j] &lt; a[nMinIndex])</span><br><span class="line">                nMinIndex = j;</span><br><span class="line"> </span><br><span class="line">        Swap(a[i], a[nMinIndex]); //将这个元素放到无序区的开头</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="关于swap的使用"><a href="#关于swap的使用" class="headerlink" title="关于swap的使用"></a>关于swap的使用</h2><h3 id="如何不使用中间数来进行数组中数字交换？"><a href="#如何不使用中间数来进行数组中数字交换？" class="headerlink" title="如何不使用中间数来进行数组中数字交换？"></a>如何不使用中间数来进行数组中数字交换？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void Swap1(int[] arr,int a, int b) &#123;</span><br><span class="line">        if (arr[a] != arr[b]) &#123;</span><br><span class="line">            arr[a] ^= arr[b];</span><br><span class="line">            arr[b] ^= arr[a];</span><br><span class="line">            arr[a] ^= arr[b];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>数组为引用类型，对数组进行修改，原数组的内容也会被修改，所以这里调用方法之后数组两个数据会被调换;如果传入int类型，为基本数据类型，只是传入数字到方法中，对main函数中的a,b并没有影响，不会被改变</p></blockquote><hr><p>参考链接<a href="https://blog.csdn.net/MoreWindows/article/details/17488865" target="_blank" rel="noopener">https://blog.csdn.net/MoreWindows/article/details/17488865</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;&lt;center&gt;排序算法&lt;/center&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0068YiZcgy1fu71g2x4utj30rs0jnqbw.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java面试(一)</title>
    <link href="http://yoursite.com/2018/08/10/Java%E9%9D%A2%E8%AF%95-%E4%B8%80/"/>
    <id>http://yoursite.com/2018/08/10/Java面试-一/</id>
    <published>2018-08-10T04:34:35.000Z</published>
    <updated>2018-08-13T06:46:15.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java基础面试问题总结"><a href="#java基础面试问题总结" class="headerlink" title="java基础面试问题总结"></a><center>java基础面试问题总结</center></h1><p><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1fu4ie0t80jj30xc0i5k60.jpg" alt=""><br><a id="more"></a></p><h4 id="1-Java中的值传递和引用传递："><a href="#1-Java中的值传递和引用传递：" class="headerlink" title="1. Java中的值传递和引用传递："></a>1. Java中的值传递和引用传递：</h4><hr><p>对象传递（数组、类、接口）是引用传递，原始类型数据（整型、浮点型、字符型、布尔型）传递是值传递。</p><p><strong>值传递</strong>是指对象被值传递，意味着传递了对象的一个副本，即使副本被改变，也不会影响源对象。（因为值传递的时候，实际上是将实参的值复制一份给形参。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int num1 = 10;</span><br><span class="line">    int num2 = 20;</span><br><span class="line"></span><br><span class="line">    swap(num1, num2);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;num1 = &quot; + num1);</span><br><span class="line">    System.out.println(&quot;num2 = &quot; + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void swap(int a, int b) &#123;</span><br><span class="line">    int temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;a = &quot; + a);</span><br><span class="line">    System.out.println(&quot;b = &quot; + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 20</span><br><span class="line">b = 10</span><br><span class="line">num1 = 10</span><br><span class="line">num2 = 20</span><br></pre></td></tr></table></figure></p><p><strong>引用传递</strong>是指对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象的改变会反映到所有的对象上。（因为引用传递的时候，实际上是将实参的地址值复制一份给形参。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int[] arr = &#123;1,2,3,4,5&#125;;</span><br><span class="line"></span><br><span class="line">    change(arr);</span><br><span class="line"></span><br><span class="line">    System.out.println(arr[0]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void change(int[] array) &#123;</span><br><span class="line">    //将数组的第一个元素变为0</span><br><span class="line">    array[0] = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><h4 id="2-与equals"><a href="#2-与equals" class="headerlink" title="2. ==与equals"></a>2. ==与equals</h4><hr><p>== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。</p><p>equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><p>情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。<br>情况2：类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class test1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String a = new String(&quot;ab&quot;); // a 为一个引用</span><br><span class="line">        String b = new String(&quot;ab&quot;); // b为另一个引用,对象的内容一样</span><br><span class="line">        String aa = &quot;ab&quot;; // 放在常量池中</span><br><span class="line">        String bb = &quot;ab&quot;; // 从常量池中查找</span><br><span class="line">        if (aa == bb) // true</span><br><span class="line">            System.out.println(&quot;aa==bb&quot;);</span><br><span class="line">        if (a == b) // false，非同一对象</span><br><span class="line">            System.out.println(&quot;a==b&quot;);</span><br><span class="line">        if (a.equals(b)) // true</span><br><span class="line">            System.out.println(&quot;aEQb&quot;);</span><br><span class="line">        if (42 == 42.0) &#123; // true</span><br><span class="line">            System.out.println(&quot;true&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><ul><li>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。</li><li>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</li></ul><h4 id="3-hashCode与equals"><a href="#3-hashCode与equals" class="headerlink" title="3. hashCode与equals"></a>3. hashCode与equals</h4><hr><ul><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个对象分别调用equals方法都返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li>因此，equals方法被覆盖过，则hashCode方法也必须被覆盖</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ul><h4 id="4-面向对象和面向过程的区别"><a href="#4-面向对象和面向过程的区别" class="headerlink" title="4. 面向对象和面向过程的区别"></a>4. 面向对象和面向过程的区别</h4><hr><h5 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h5><ul><li>优点：性能高，因为类调用时需要实例化，开销比较大，比较消耗资源；比如嵌入式开发，Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</li><li>缺点：没有面向对象易维护，易复用，易扩展。<h5 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h5></li><li>优点：易维护，易复用，易扩展，由于面向对象有封装，继承，多态的特性，可以设计出低耦合的系统，使系统更加的灵活，易于维护。</li><li>性格比面向过程低。</li></ul><h4 id="5-Java代码运行过程"><a href="#5-Java代码运行过程" class="headerlink" title="5.Java代码运行过程"></a>5.Java代码运行过程</h4><hr><p>Java源代码—-&gt;编译器—-&gt;jvm可执行的Java字节码(即.class文件中的虚拟指令)—-&gt;jvm—-&gt;jvm中的解释器—-&gt;机器可执行的二进制机器码—-&gt;程序运行</p><h5 id="采用字节码的好处"><a href="#采用字节码的好处" class="headerlink" title="采用字节码的好处"></a>采用字节码的好处</h5><p>一定程度上解决了传统解释性语言执行效率低的问题，同时又保持了解释性语言可移植的特点。在运行java程序时比较高效。而且因为字节码并不专对一种特定的机器，因此java程序无需重新编译便可在多种不同的计算机上运行。</p><h4 id="6-java与c-的区别"><a href="#6-java与c-的区别" class="headerlink" title="6. java与c++的区别"></a>6. java与c++的区别</h4><hr><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java不提供指针来直接访问内存，程序内存更加安全</li><li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。</li><li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li></ul><h4 id="7-重载和重写的区别"><a href="#7-重载和重写的区别" class="headerlink" title="7. 重载和重写的区别"></a>7. 重载和重写的区别</h4><hr><p><strong>重载</strong></p><p>同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　</p><p><strong>重写</strong></p><p>发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private则子类就不能重写该方法。</p><h4 id="8-Java面向对象编程的三大特性：封装，继承，多态"><a href="#8-Java面向对象编程的三大特性：封装，继承，多态" class="headerlink" title="8. Java面向对象编程的三大特性：封装，继承，多态"></a>8. Java面向对象编程的三大特性：封装，继承，多态</h4><hr><p><strong>封装</strong></p><p>封装是将一个对象的属性私有化，同时提供一些给外界访问的属性的方法(private, getter and setter)</p><p><strong>继承</strong></p><p>继承是将已经存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以使用父类的功能，但不能选择性的继承父类。</p><p><strong>关于继承的三点</strong></p><ol><li>子类拥有父类非private的属性和方法(父类的构造方法同样不能被继承)</li><li>子类可以拥有自己的属性和方法</li><li>子类可以用自己的方法实现父类的方法(重写)</li></ol><p><strong>多态</strong></p><p>多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p>java中有两种形式可以实现多态：继承(多个子类对同一方法的重写)和接口(实现接口并覆盖接口中的同一方法).</p><h4 id="9-String、StringBuffer和StringBuilder的却别是什么？String为什么是不可变的"><a href="#9-String、StringBuffer和StringBuilder的却别是什么？String为什么是不可变的" class="headerlink" title="9. String、StringBuffer和StringBuilder的却别是什么？String为什么是不可变的"></a>9. String、StringBuffer和StringBuilder的却别是什么？String为什么是不可变的</h4><hr><p><strong>可变性</strong></p><p>String类中使用字符数组来保存字符串，private、final、char、value[]，所以String对象是不变的。StringBuffer和StringBuilder都继承自AbstractStringBuilder类，在这个类中也是使用字符数组保存字符串，char、value[]，所以这两种对象是可变的。</p><p><strong>线程安全性</strong></p><ul><li>String中对象是不变的，线程安全</li><li>StringBuffer对方法加了同步锁或者对调用方法添加了同步锁，线程安全</li><li>StringBuilder并没有对方法添加同步锁，所以非线程安全</li></ul><p><strong>性能</strong></p><p>由于对String修改的时候都会生成一个新的String对象，然后将指针指向新的String对象；StringBuffer每次都会对对象本身进行操作，而不是生成新的对象。相同情况下StringBuilder要比StringBuffer性能提高10%~15%左右，但是线程不安全</p><p><strong>使用情况</strong></p><ul><li>String：操作少量的数据用</li><li>StringBuffer: 多线程操作字符串缓冲区下大量数据</li><li>StringBuilder：单线程下操作字符串缓冲区中大量数据</li></ul><h4 id="10-Java中空参构造方法的作用？"><a href="#10-Java中空参构造方法的作用？" class="headerlink" title="10. Java中空参构造方法的作用？"></a>10. Java中空参构造方法的作用？</h4><hr><p>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p><blockquote><p>在java的子类中，不会继承父类的构造函数，但是在子类实例化的时候会调用父类的构造函数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        A ab=new B();  //执行到此处,结果: 1a2b</span><br><span class="line">        ab=new B();//执行到此处,结果: 1a2b2b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class A&#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.print(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public A() &#123;</span><br><span class="line">        System.out.print(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class B extends A&#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.print(&quot;a&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public B() &#123;</span><br><span class="line">        System.out.print(&quot;b&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-接口和抽象类的区别"><a href="#11-接口和抽象类的区别" class="headerlink" title="11. 接口和抽象类的区别"></a>11. 接口和抽象类的区别</h4><hr><ul><li>接口的方法默认是public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法</li><li>接口中的实例变量默认是final类型的，而抽象类中则不一定</li><li>一个类可以实现多个接口，但最多只能实现一个抽象类</li><li>一个类实现接口的话要实现接口的所有方法，而抽象类不一定</li><li>接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象；从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</li></ul><h4 id="12-成员变量与局部变量的区别有那些？"><a href="#12-成员变量与局部变量的区别有那些？" class="headerlink" title="12.  成员变量与局部变量的区别有那些？"></a>12.  成员变量与局部变量的区别有那些？</h4><hr><ul><li>从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；但是，成员变量和局部变量都能被final所修饰；</li><li>从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存</li><li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li><li>成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被final修饰但没有被static修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。</li></ul><h4 id="13-简述线程，程序、进程的基本概念。以及他们之间关系是什么？"><a href="#13-简述线程，程序、进程的基本概念。以及他们之间关系是什么？" class="headerlink" title="13. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？"></a>13. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？</h4><hr><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p><p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。++线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定++，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p><h4 id="14-线程有哪些基本状态？这些状态是如何定义的"><a href="#14-线程有哪些基本状态？这些状态是如何定义的" class="headerlink" title="14. 线程有哪些基本状态？这些状态是如何定义的"></a>14. 线程有哪些基本状态？这些状态是如何定义的</h4><hr><ol><li>新建(new)：新创建了一个线程对象。</li><li>可运行(runnable)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。</li><li>运行(running)：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。</li><li>阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种： (一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waitting queue)中。 (二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。 (三). 其他阻塞: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</li><li>死亡(dead)：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。<br><img src="https://camo.githubusercontent.com/5b764ff5af6204f82c7ae6237b20c41f9505aef8/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f382f392f313635316631396437633465393361333f773d38373626683d34393226663d706e6726733d313238303932" alt="image"></li></ol><hr><p>面试问题基本都在链接中，我只不过手打了一遍增强记忆，如有侵权，私信我删QAQ</p><p>参考链接<a href="https://github.com/Snailclimb/Java-Guide" target="_blank" rel="noopener">https://github.com/Snailclimb/Java-Guide</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;java基础面试问题总结&quot;&gt;&lt;a href=&quot;#java基础面试问题总结&quot; class=&quot;headerlink&quot; title=&quot;java基础面试问题总结&quot;&gt;&lt;/a&gt;&lt;center&gt;java基础面试问题总结&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0068YiZcgy1fu4ie0t80jj30xc0i5k60.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="java，面试" scheme="http://yoursite.com/tags/java%EF%BC%8C%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>windows使用git遇到HttpRequestException</title>
    <link href="http://yoursite.com/2018/07/23/windows%E4%BD%BF%E7%94%A8git%E9%81%87%E5%88%B0HttpRequestException/"/>
    <id>http://yoursite.com/2018/07/23/windows使用git遇到HttpRequestException/</id>
    <published>2018-07-23T05:01:50.000Z</published>
    <updated>2018-08-13T06:48:31.957Z</updated>
    
    <content type="html"><![CDATA[<p><center>win10使用git进行<code>git push</code>时出现<code>Fatal: HttpRequestException encountered</code>并且需要重新输入用户名和密码的解决方案</center><br><a id="more"></a></p><p>这是因为github<a href="https://githubengineering.com/crypto-removal-notice/" target="_blank" rel="noopener">禁用了弱加密</a>,可以下载<a href="https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/tag/v1.16.2" target="_blank" rel="noopener">最新版本的Git凭据管理器</a>来解决这个问题。<br><img src="https://ws1.sinaimg.cn/large/0068YiZcgy1ftjqev6e56j30sq08s752.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;win10使用git进行&lt;code&gt;git push&lt;/code&gt;时出现&lt;code&gt;Fatal: HttpRequestException encountered&lt;/code&gt;并且需要重新输入用户名和密码的解决方案&lt;/center&gt;&lt;br&gt;
    
    </summary>
    
      <category term="遇到的问题" scheme="http://yoursite.com/categories/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>mongodb无法安装的问题解决</title>
    <link href="http://yoursite.com/2018/06/30/mongodb%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2018/06/30/mongodb无法安装的问题解决/</id>
    <published>2018-06-30T08:10:49.000Z</published>
    <updated>2018-08-13T06:48:13.154Z</updated>
    
    <content type="html"><![CDATA[<p><center>win10安装mongodb遇到mongodb 3.6.5 2008 Setup Wizard ended prematurely问题，无法安装</center><br><a id="more"></a></p><p><img src="https://img-blog.csdn.net/20180619214846303?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjQ0NDk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>解决问题方法：安装的时候取消Compass</p><p><img src="https://img-blog.csdn.net/20180619214953834?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjQ0NDk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>安装成功：<br><img src="https://img-blog.csdn.net/20180619215043676?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjQ0NDk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;win10安装mongodb遇到mongodb 3.6.5 2008 Setup Wizard ended prematurely问题，无法安装&lt;/center&gt;&lt;br&gt;
    
    </summary>
    
      <category term="遇到的问题" scheme="http://yoursite.com/categories/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="mongodb" scheme="http://yoursite.com/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>HelloBlog</title>
    <link href="http://yoursite.com/2018/06/24/HelloBlog/"/>
    <id>http://yoursite.com/2018/06/24/HelloBlog/</id>
    <published>2018-06-24T08:22:35.000Z</published>
    <updated>2018-08-13T06:45:04.596Z</updated>
    
    <content type="html"><![CDATA[<p><center>其实在很久之前大概就像有一个自己的个人博客，大概有多久之前呢，大概是两年前，鬼知道这两年我干了什么＝＝</center><br><a id="more"></a><br>关于博客，采用hexo＋github Pages初步已经搭建完成，也把很多细节和需要修改的东西调整的差不多了，这个博客的搭建大概就结束了，接下来就可以慢慢写自己的博客啦，唯一美中不足的是对于MardDown的语法还不是很熟悉，前路漫漫<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"HelloMyBlog"</span>);</span><br></pre></td></tr></table></figure></p><p>辞树</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;其实在很久之前大概就像有一个自己的个人博客，大概有多久之前呢，大概是两年前，鬼知道这两年我干了什么＝＝&lt;/center&gt;&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="hello" scheme="http://yoursite.com/tags/hello/"/>
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
</feed>
